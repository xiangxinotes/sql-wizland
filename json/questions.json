{
    "1" : [
        {
        "question_id": 1,
        "question_text_before_options": "SELECT customer_id, customer_name FROM customers WHERE customer_name ",
        "options": ["LIKE", "="],
        "question_text_after_options": " '%John%';",
        "question_comment": "本题解题线索是挖空处后面的 '%John%'。在 SQL 中，'%John%' 这样的表达式通常用于在进行文本数据的查询操作时，实现模糊匹配的功能，因此这里应该使用用于模糊查询的 LIKE。= 是用于精确匹配的，所以用 = 不会返回我们想要的结果，因为不会有顾客名称恰好等于 %John% 这样带有通配符的字符串。",
        "knowledge_comment":"= 在 SQL 中用于精确匹配。而 LIKE 用于模糊查询，一般会搭配正则表示式使用。如果你没听说过正则表示式，正则表达式的应用场景很多，一定要去学习。",
        "correct_answer": "LIKE",
        "applicable_databases": ["MySQL", "SQL Server", "Oracle"]
    },
    {
        "question_id": 2,
        "question_text_before_options": "查出 products 表中价格在 50-100 区间的产品: SELECT product_id, product_name, price FROM products WHERE price ",
        "options": ["IN (50, 100)", "BETWEEN 50 AND 100"],
        "question_text_after_options": ";",
        "question_comment": "题干明确指出需要查询的是 50-100 区间，也就是说：50, 51, 52, ... ,99, 100 都需要被查询并返回。IN 只能用于判断一个值是否在指定的集合中，所以用 IN 只会返回价格恰好是 50 或者 100 的产品。",
        "knowledge_comment":"IN 和 BETWEEN AND 都用于在一定条件下筛选数据，使用时一定要注意区别。区别在于：IN 用于判断一个值是否在指定的集合中，BETWEEN AND 用于判断一个值是否在一个连续的区间内。",
        "correct_answer": "BETWEEN 50 AND 100",
        "applicable_databases": ["MySQL", "SQL Server", "Oracle"]
    },
    {
        "question_id": 3,
        "question_text_before_options": "SELECT product_id, ",
        "options": ["SUM", "AVG"],
        "question_text_after_options": " (quantity) as average_quantity FROM sales GROUP BY product_id;",
        "question_comment": "本题解题线索是 as average_quantity，即平均数量，对查询变量的重命名暗示了此题想查询每种产品的平均销售数量。SUM 是求和函数，AVG 是求平均值函数，答案一目了然了。",
        "knowledge_comment": "SUM 和 AVG 都是对数值列进行计算的函数，SUM 是 Summation (求和) 的简写，用于求和，AVG 是 Average (平均) 的简写，用于求平均值。还有其他的函数，比如计算的函数，比如 MAX 和 MIN，函数名都是英文单词简写，可以遇到一个积累一个。",
        "correct_answer": "AVG",
        "applicable_databases": ["MySQL", "SQL Server", "Oracle"]
    },
    {
        "question_id": 4,
        "question_text_before_options": "查出所有员工及其所在部门的信息: SELECT employees.employee_id, employees.department_id, departments.department_name FROM employees ",
        "options": ["JOIN", "LEFT JOIN"],
        "question_text_after_options": " departments ON employees.department_id = departments.department_id;",
        "question_comment": "题干明确指出需要查询的是所有员工的信息，也就是说只要一个员工信息存在于 employees 表中，就应该返回（即使此员工还没有分配department），所以应该使用 LEFT JOIN 以 employees 表为基准返回结果。",
        "knowledge_comment": "JOIN，也就是 INNER JOIN，是内连接，它只会返回两个表的交集（也就是满足连接条件的匹配记录）； LEFT JOIN，也就是 LEFT OUTTER JOIN 的简写，是左外连接，它会返回左边表中的所有数据（即使和右边表没有匹配记录也会被返回）。",
        "correct_answer": "LEFT JOIN",
        "applicable_databases": ["MySQL", "SQL Server", "Oracle"]
    },
    {
        "question_id": 5,
        "question_text_before_options": "SELECT class_id, ",
        "options": ["COUNT(*)", "COUNT(name)"],
        "question_text_after_options": " as number_of_students FROM students GROUP BY class_id;",
        "question_comment": "本题解题线索是 as number_of_students，即学生数量，对查询变量的重命名暗示了此题想查询每个班的学生数量。COUNT 是计数函数，COUNT(*) 统计所有行的个数，而 COUNT(name) 只统计 name 列非空值的行的个数，因此如果 name 列存在空值，就会出现统计数量比真实情况少的情况。",
        "knowledge_comment": "COUNT(*) 和 COUNT(列名) 是有区别的。COUNT (*) 是用于统计包括空值在内的所有行的；而 COUNT (列名) 不统计空值行，所以如果 列名 这一列存在空值，那么统计的结果将会少于真实数据。",
        "correct_answer": "COUNT(*)",
        "applicable_databases": ["MySQL", "SQL Server", "Oracle"]
    },
    {
        "question_id": 6,
        "question_text_before_options": "查出 A、B 两班所有学生的考试成绩: SELECT student_name, subject, score FROM classa",
        "options": ["UNION", "UNION ALL"],
        "question_text_after_options": " SELECT student_name, subject, score FROM classb;",
        "question_comment": "题干明确指出需要查询的是 A、B 两班所有学生的考试成绩，而且可以看到查询的是学生姓名、科目、成绩三项，那就必须使用 UNION ALL 来确保重名学生的成绩都能被返回到结果中。",
        "knowledge_comment": "UNION，合并结果集并去除重复行； UNION ALL，合并结果集并保留所有行，包括重复行。",
        "correct_answer": "UNION ALL",
        "applicable_databases": ["MySQL", "SQL Server", "Oracle"]
    },
    {
        "question_id": 7,
        "question_text_before_options": "SELECT department_id, last_name, first_name, salary FROM employees",
        "options": ["ORDER BY", "GROUP BY"],
        "question_text_after_options": " salary DESC, department_id;",
        "question_comment": "本题解题线索是 salary DESC 中的 DESC，即降序，涉及到排序，那么必然选择ORDER BY。",
        "knowledge_comment": "ORDER BY，对查询返回的结果集按照指定的列进行排序，可以按照某一列排序或者同时按照多列进行排序，排序的顺序可以是升序 (ASC 或留空) 或者降序 (DESC)； GROUP BY，将条目分组，以便对每个组执行聚合函数（比如 COUNT(), MAX(), MIN(), SUM(), AVG() 等）。",
        "correct_answer": "ORDER BY",
        "applicable_databases": ["MySQL", "SQL Server", "Oracle"]
    },
    {
        "question_id": 8,
        "question_text_before_options": "查出每种产品的平均价格(四舍五入保留两位小数): SELECT product_id",
        "options": ["ROUND", "TRUNCATE"],
        "question_text_after_options": " (AVG(price), 2) FROM products GROUP BY product_id;",
        "question_comment": "题干明确指出需要查询的是每种产品的平均价格，需要四舍五入，并且保留两位小数，因此选择ROUND，因为ROUND会进行四舍五入。",
        "knowledge_comment": "ROUND，按指定位数对数值进行四舍五入，ROUND(number, 2) 即按照2位数对 number 进行四舍五入，若 number = 2.339，则 ROUND(number, 2) = 2.34； TRUNCATE，按照位数对数值进行截取，TRUNCATE(number, 2)即按照2位数对 number 进行截取，若 number = 2.339，则 TRUNCATE(number, 2) = 2.33",
        "correct_answer": "ROUND",
        "applicable_databases": ["MySQL"]
    },
    {
        "question_id": 9,
        "question_text_before_options": "查出每种产品的平均价格(四舍五入保留两位小数): SELECT product_id",
        "options": ["ROUND", "TRUNC"],
        "question_text_after_options": " (AVG(price), 2) FROM products GROUP BY product_id;",
        "question_comment": "题干明确指出需要查询的是每种产品的平均价格，需要四舍五入，并且保留两位小数，因此选择ROUND，因为ROUND会进行四舍五入。",
        "knowledge_comment": "ROUND，按指定位数对数值进行四舍五入，ROUND(number, 2) 即按照2位数对 number 进行四舍五入，若 number = 2.339，则 ROUND(number, 2) = 2.34； TRUNC，按照位数对数值进行截取，TRUNC(number, 2)即按照2位数对 number 进行截取，若 number = 2.339，则 TRUNC(number, 2) = 2.33",
        "correct_answer": "ROUND",
        "applicable_databases": ["Oracle", "PostgreSQL"]
    },
    {
        "question_id": 10,
        "question_text_before_options": "查出每种产品的平均价格(四舍五入保留两位小数): SELECT product_id",
        "options": ["ROUND(AVG(price), 2)", "ROUND(AVG(price), 2, 1)"],
        "question_text_after_options": " FROM products GROUP BY product_id;",
        "question_comment": "题干明确指出需要查询的是每种产品的平均价格，需要四舍五入，并且保留两位小数，因此选择ROUND(AVG(price), 2)，因为在没有第三个参数的情况下，ROUND会进行四舍五入。",
        "knowledge_comment": "ROUND(n,d)，按指定 d 位数对数值 n 进行四舍五入，ROUND(number, 2) 即按照2位数对 number 进行四舍五入，若 number = 2.339，则 ROUND(number, 2) = 2.34； ROUND(n,d,f)，根据 f 大小按指定 d 位数对数值 n 进行截取（当 f 为0时，即默认值，需要对数值进行四舍五入；当 f 大于0时，不进行四舍五入，直接截取），ROUND(number, 2, 1)即按照2位数直接对 number 进行截取，若 number = 2.339，则 ROUND(number, 2, 1) = 2.33",
        "correct_answer": "ROUND(AVG(price), 2)",
        "applicable_databases": ["SQL Server"]
    }],
    "2" : [
        {
        "question_id": 1,
        "question_text_before_options": "查询员工信息和其部门信息：SELECT * FROM employees ",
        "options": ["JOIN", "UNION"],
        "question_text_after_options": " departments ON employees.department_id = departments.department_id;",
        "question_comment": "UNION 用于合并两个或多个 SELECT 语句的结果集，而且要求列数、对应列的数据类型等要一致，所以 UNION 的前后必须都包含 SELECT 语句，这道题 UNION 后面的部分没有 SELECT 语句，所以应该选择JOIN。",
        "knowledge_comment": "JOIN 用于表与表之间基于关联条件的连接操作，能获取到符合关联逻辑的综合数据；UNION 侧重合并多个查询结果集，二者功能不同，使用场景有明显区别，要准确掌握。",
        "correct_answer": "JOIN",
        "applicable_databases": ["MySQL", "SQL Server", "Oracle"]
    },
    {
        "question_id": 2,
        "question_text_before_options": "SELECT * FROM employees INNER JOIN departments ",
        "options": ["ON", "WHERE"],
        "question_text_after_options": " employees.department_id = departments.department_id",
        "question_comment": "在标准 SQL 中，当使用 INNER JOIN 时，如果没有 ON 子句，语法是错误的。因为 INNER JOIN 需要基于某些列的关联条件来确定如何连接两个表，而这个关联条件是通过 ON 子句来指定的，所以这里应该选择 ON。",
        "knowledge_comment": "你可能会在测试中发现这里选择 ON 和 WHERE 会产生同样的结果，这是因为你的 MySQL 版本较旧或者有特定的数据库配置导致的，但使用 INNER JOIN 时没有 ON 子句是不符合标准规范的行为，请不要这样编写代码。",
        "correct_answer": "ON",
        "applicable_databases": ["MySQL"]
    },
    {
        "question_id": 3,
        "question_text_before_options": "SELECT * FROM employees INNER JOIN departments ",
        "options": ["ON", "WHERE"],
        "question_text_after_options": " employees.department_id = departments.department_id",
        "question_comment": "在标准 SQL 中，当使用 INNER JOIN 时，如果没有 ON 子句，语法是错误的。因为 INNER JOIN 需要基于某些列的关联条件来确定如何连接两个表，而这个关联条件是通过 ON 子句来指定的，所以这里应该选择 ON。",
        "knowledge_comment": "和 MySQL 不同，使用 INNER JOIN 但没有 ON 子句，一定会产生语法错误，如果你有其他需要过滤的条件，可以用 AND 加到 ON 子句中，或者用 WHERE 写到 ON 子句后。",
        "correct_answer": "ON",
        "applicable_databases": ["SQL Server", "Oracle"]
    },
    {
        "question_id": 4,
        "question_text_before_options": "SELECT stores.store_name, products.product_name FROM stores <strong>JOIN</strong> products ON stores.store_id = products.store_id 中的 JOIN 是",
        "options": ["NATURAL JOIN", "OUTER JOIN", "INNER JOIN", "LEFT JOIN", "RIGHT JOIN", "CROSS JOIN"],
        "question_text_after_options": "的简写。",
        "question_comment": "在 SQL 中，JOIN（不带修饰词时）默认是 INNER JOIN。这意味着在大多数情况下，当你想要进行内连接操作时，使用 JOIN 和 INNER JOIN 是等效的。",
        "knowledge_comment": "虽然在 SQL 中，INNER JOIN 中的 INNER 可以省略，但为了代码的清晰性和可读性，明确使用 INNER JOIN 可能是更好的选择。",
        "correct_answer": "INNER JOIN",
        "applicable_databases": ["MySQL", "SQL Server", "Oracle"]
    },
    {
        "question_id": 5,
        "question_text_before_options": "在语法格式上符合使用自然连接的要求（假设各表有合适的同名关联字段）的是：SELECT * FROM products ",
        "options": ["NATURAL JOIN", "JOIN"],
        "question_text_after_options": " categories;",
        "question_comment": "NATURAL JOIN是基于两张表中同名字段自动进行连接的一种连接方式，语法上直接使用NATURAL JOIN关键字跟要连接的表名就行。而JOIN后面通常需要跟具体的连接条件（如ON子句等），题目要求使用自然连接，所以选项中用NATURAL JOIN这种连续使用自然连接关键字去连接多个表的格式才符合要求，JOIN的那种写法不符合自然连接语法格式。",
        "knowledge_comment": "NATURAL JOIN语法相对简洁，依靠同名字段自动关联，但使用时要确保表中同名字段确实是用于关联的合理字段，同时要区分它和普通JOIN在语法及使用方式上的不同。",
        "correct_answer": "NATURAL JOIN",
        "applicable_databases": ["MySQL", "SQL Server", "Oracle"]
    },
    {
        "question_id": 6,
        "question_text_before_options": "查询员工工资记录，要求所有员工的工资记录都要显示（即使有些员工没有对应的工资记录情况也显示）：SELECT * FROM salaries ",
        "options": ["RIGHT JOIN", "LEFT JOIN"],
        "question_text_after_options": " employees ON salaries.employee_id = employees.employee_id;",
        "question_comment": "RIGHT JOIN是以右边的表（这里是employees表）为主，会返回右边表的所有记录以及与左边表匹配的记录，符合题目要求，所以要用RIGHT JOIN。",
        "knowledge_comment": "RIGHT JOIN，RIGHT OUTER JOIN 的简写，与LEFT JOIN刚好相反，RIGHT JOIN侧重于保留右表全部记录并关联左表匹配记录，LEFT JOIN反之，保留左表全部记录并关联右表匹配记录，要根据实际需求中对表记录保留及关联的侧重来选用合适的连接类型。",
        "correct_answer": "RIGHT JOIN",
        "applicable_databases": ["MySQL", "SQL Server", "Oracle"]
    },
    {
        "question_id": 7,
        "question_text_before_options": "获取所有学生及对应的课程信息（即使没选课的学生也显示）：SELECT students.student_name, courses.course_name FROM students ",
        "options": ["LEFT JOIN", "INNER JOIN"],
        "question_text_after_options": " student_courses ON students.student_id = student_courses.student_id LEFT JOIN courses ON student_courses.course_id = courses.course_id;",
        "question_comment": "INNER JOIN只会返回两个表中满足连接条件的交集数据，也就是只有选了课的学生信息才会被显示出来。而LEFT JOIN是以左边的表（这里先以students表为主），会返回左边表的所有记录以及与右边表匹配的记录，所以即使没选课的学生也能显示出来，为了符合题目要求显示所有学生的情况，要用LEFT JOIN。",
        "knowledge_comment": "INNER JOIN和LEFT JOIN是多表连接中常用的不同连接方式，INNER JOIN取交集，LEFT JOIN 是 LEFT OUTER JOIn的简写，侧重于保留左表全部记录，要依据具体需求选择合适的连接类型来获取期望的数据。",
        "correct_answer": "LEFT JOIN",
        "applicable_databases": ["MySQL", "SQL Server", "Oracle"]
    },
    {
        "question_id": 8,
        "question_text_before_options": "SELECT * FROM employees INNER JOIN departments ",
        "options": ["ON", "USING"],
        "question_text_after_options": " (department_id);",
        "question_comment": "本题解题线索是挖空处后面的 (department_id)，因为 ON 必须明确写出两个表的列名来定义连接条件，所以这里选择 USING。如果要使用 ON 完成本题，那么挖空处后面应该写成 employees.department_id = departments.department_id",
        "knowledge_comment": "在连接两个表时，如果连接列名相同，那么用 ON 和 USING 都是可以的，相比较而言，USING 的语法更简洁，而 ON 则需要明确写出两个表的列名来定义连接条件。",
        "correct_answer": "USING",
        "applicable_databases": ["MySQL", "SQL Server", "Oracle"]
    },
    {
        "question_id": 9,
        "question_text_before_options": "SELECT basket_name, fruit_name FROM baskets ",
        "options": ["INNER JOIN", "FULL OUTER JOIN"],
        "question_text_after_options": " fruits ON baskets.basket_id = fruits.basket_id WHERE baskets.basket_id IS NOT NULL AND fruits.basket_id IS NULL;",
        "question_comment": "本题解题线索是 WHERE 后面的条件，即没有放到篮子中的水果。因为 INNER JOIN 只会返回放到篮子中的水果，所以使用此过滤逻辑会返回空，肯定不符合实际情况。",
        "knowledge_comment": "FULL OUTER JOIN 可以简写为 FULL JOIN，它返回左表和右表中的所有行。如果左表中的行在右表中没有匹配的行，右表对应的列填充为NULL；反之，如果右表中的行在左表中没有匹配的行，左表对应的列填充为NULL。如果你使用的数据库不支持 FULL OUTER JOIN，你可以用 LEFT OUTER JOIN UNION RIGHT OUTER JOIN 代替。",
        "correct_answer": "FULL OUTER JOIN",
        "applicable_databases": ["MySQL", "SQL Server", "Oracle"]
    },
    {
        "question_id": 10,
        "question_text_before_options": "查询所有可能的商品类别和颜色组合：SELECT pc.category_name, c.color_name FROM product_categories pc ",
        "options": ["CROSS JOIN", "FULL JOIN"],
        "question_text_after_options": " colors c;",
        "question_comment": "本题解题线索是不包含 ON 子句，在标准 SQL 语法中，FULL JOIN（全外连接）通常需要跟ON子句。ON子句用于指定两个表之间的连接条件，也就是告诉数据库如何根据两个表中的列来匹配行。在某些情况下，如果没有ON子句，数据库系统可能会尝试根据表中的列名自动匹配（如果存在同名且数据类型兼容的列），或者按照某种默认规则进行连接，但这种行为是非标准的，并且不同数据库系统的处理方式可能不同。某些数据库的旧版本或者特定配置下，可能会将没有ON子句的FULL JOIN当作CROSS JOIN（笛卡尔积）来处理，请不要这样编写代码。",
        "knowledge_comment": "使用 CROSS JOIN 会生成两个表之间的笛卡尔积。当需要为新系统或者功能创建测试数据时，CROSS JOIN往往会派上用场，但在使用CROSS JOIN时要特别小心，因为它会产生笛卡尔积，导致结果集的数据量可能会急剧增长，导致性能问题，如占用大量的内存和磁盘空间，甚至使数据库服务器崩溃。",
        "correct_answer": "CROSS JOIN",
        "applicable_databases": ["MySQL", "SQL Server", "Oracle"]
    }],
    "3" : [
        {
            "question_id": 1,
            "question_text_before_options": "计算3天后的日期：SELECT ",
            "options": ["DATE_ADD", "DATE_SUB" ,"DATE_DIFF","PLUS_DATE"],
            "question_text_after_options": "(launch_date, INTERVAL 3 DAY) AS expire_date from products;",
            "question_comment": "本题可使用排除法。DATE_DIFF 的写法不对，正确的函数名应该是DATEDIFF，因此可以排除；PLUS_DATE 并非任何主流数据库里的内置函数名，也可以排除。DATE_ADD，DATE_SUB 都是 MySQL中内置的函数名，但作用不一样，通过它们的名字也可以看出，一个是ADD（加法）；一个是SUB（减法），因为是计算3天后的日期，因此应该是用加法，在现在的日期上加上3天，所以选择 DATE_ADD。",
            "knowledge_comment": "在 MySQL 中，DATE_ADD() 函数用于对日期进行加法操作。它接收一个日期值和一个时间间隔作为参数，返回一个新的日期。",
            "correct_answer": "DATE_ADD",
            "applicable_databases": ["MySQL"]
        },
        {
            "question_id": 1,
            "question_text_before_options": "计算3天后的日期：SELECT ",
            "options": ["DATE_ADD", "DATEADD", "DATESUB", "DATEDIFF"],
            "question_text_after_options": "(DAY, 3, launch_date) expire_date from products;",
            "question_comment": "DATE_ADD 是 MySQL 的内置函数名，用于对日期进行加法操作。DATE_ADD 函数的语法是：DATE_ADD(date, INTERVAL value unit)；DATEADD() 函数的参数顺序和 DATE_ADD() 有所不同，它要求先指定时间间隔类型，接着是间隔值，最后是日期；DATESUB 并非任何主流数据库里的内置函数名，可以排除；DATEDIFF 函数用来计算两个日期之前的间隔，语法是：DATEDIFF(datepart, startdate, enddate)",
            "knowledge_comment": "DATEADD 的语法是：DATEADD(datepart, number, date)，需要注意的是因为 SQL Server 没有 DATASUB 函数，所以如果想要计算几天前的日期，仍需使用 DATEADD，不同的是，number 参数填写负值。如果需要计算3天前的日期：(DAY, -3, launch_date)",
            "correct_answer": "DATEADD",
            "applicable_databases": ["SQL Server"]
        },
        {
            "question_id": 1,
            "question_text_before_options": "计算3天后的日期：SELECT ",
            "options": ["DATEADD(DAY, 3, launch_date)", "DATE_ADD(launch_date, INTERVAL 3 DAY)", "launch_date + 3"],
            "question_text_after_options": "AS expire_date FROM products;",
            "question_comment": "其实本题的3个选项都是有效的 SQL语句，DATEADD 是 SQL Server 的内置函数，DATE_ADD 是 MySQL 的内置函数，都可以用于计算几天后的日期。在 Oracle 数据库中，若要对日期进行加减操作，可直接使用算术运算符。",
            "knowledge_comment": "如果 launch_date 是字符串类型，还需要使用 TO_DATE 函数将日期字符串转换为日期类型。举例：SELECT TO_DATE('2025-04-11', 'YYYY-MM-DD') + 5 FROM DUAL;",
            "correct_answer": "launch_date + 3",
            "applicable_databases": ["Oracle"]
        },
        {
            "question_id": 2,
            "question_text_before_options": "SELECT * FROM users ",
            "options": ["FILTER", "HAVING", "WHERE", "CONDITION"],
            "question_text_after_options": " age > 25;",
            "question_comment": "本题可使用排除法。在 MySQL 语法里，并没有 FILTER 和 CONDITION 这样的关键字来实现筛选数据的功能；HAVING 子句通常与 GROUP BY 子句一起使用，用于对分组后的结果进行筛选，虽然 MySQL 语法上允许只写 HAVING 子句，但语义上不太符合常规用法，可能会产生不符合预期的结果。",
            "knowledge_comment": "WHERE 是基础筛选条件的关键词。",
            "correct_answer": "WHERE",
            "applicable_databases": ["MySQL"]
        },
        {
            "question_id": 2,
            "question_text_before_options": "SELECT * FROM users ",
            "options": ["FILTER", "HAVING", "WHERE", "CONDITION"],
            "question_text_after_options": " age > 25;",
            "question_comment": "本题可使用排除法。SQL Server 从 2012 版本开始支持 FILTER 修饰符，FILTER是聚合函数的修饰符，能在聚合时限制参与运算的值，相比WHERE子句更灵活，可在一个聚合查询中使用多个；在标准 SQL 语法里，并没有 CONDITION 这样的关键字来实现筛选数据的功能；HAVING 子句通常与 GROUP BY 子句一起使用，用于对分组后的结果进行筛选，没有 GROUP BY 子句时使用 HAVING 会引发语法错误。",
            "knowledge_comment": "WHERE 是基础筛选条件的关键词。",
            "correct_answer": "WHERE",
            "applicable_databases": ["SQL Server"]
        },
        {
            "question_id": 2,
            "question_text_before_options": "SELECT * FROM users ",
            "options": ["FILTER", "HAVING", "WHERE", "CONDITION"],
            "question_text_after_options": " age > 25;",
            "question_comment": "本题可使用排除法。在 Oracle 语法里，并没有 FILTER 和 CONDITION 这样的关键字来实现筛选数据的功能；HAVING 子句通常与 GROUP BY 子句一起使用，用于对分组后的结果进行筛选，没有 GROUP BY 子句时使用 HAVING 会引发语法错误。",
            "knowledge_comment": "WHERE 是基础筛选条件的关键词。",
            "correct_answer": "WHERE",
            "applicable_databases": ["Oracle"]
        },
        {
            "question_id": 3,
            "question_text_before_options": "SELECT * FROM users WHERE user_name",
            "options": ["IS NULL", "= NULL" ,"== NULL", "NOT EXISTS"],
            "question_text_after_options": ";",
            "question_comment": "NULL 代表缺失值，不能用 = 来判断一个值是否为 NULL，必须使用 IS NULL 或者 IS NOT NULL。== 是其他程序语言常用的判断符号，注意区分。NOT EXISTS 是一个用于子查询的谓词，它需要搭配子查询使用，用于判断子查询是否返回任何行。在 SELECT * FROM table WHERE user_name not exists 中，user_name 是一个列名，并非子查询，所以会导致语法错误。",
            "knowledge_comment": "SQL 中判断空值必须用 IS NULL",
            "correct_answer": "IS NULL",
            "applicable_databases": ["MySQL", "SQL Server", "Oracle"]
        },
        {
            "question_id": 4,
            "question_text_before_options": "SELECT name, CASE WHEN score >= 90 THEN 'A' WHEN score >= 80 THEN 'B' ",
            "options": ["DEFAULT", "OTHER", "ELSE"],
            "question_text_after_options": " 'C' END AS grade FROM students;",
            "question_comment": "本题可使用排除法。DEFAULT 一般在定义表结构时，用来设定列的默认值，并非用于 CASE 表达式；在标准 SQL 语法里，并没有 OTHER 这样的关键字；因此只能选择 ELSE",
            "knowledge_comment": "在标准 SQL 的 CASE 表达式里，当使用 CASE WHEN ... THEN ... 这种形式时，最后若要指定默认值，使用的关键字是 ELSE ，而非 DEFAULT 。",
            "correct_answer": "ELSE",
            "applicable_databases": ["MySQL", "SQL Server", "Oracle"]
        },
        {
            "question_id": 5,
            "question_text_before_options": "SELECT * FROM orders WHERE status ",
            "options": ["NOT IN", "NOT LIKE" ,"!=", "BETWEEN"],
            "question_text_after_options": " ('cancelled', 'refund');",
            "question_comment": "本题解题线索是 ('cancelled', 'refund')，括号中包含2个字符串说明这是一个列表，而可以放在列表前的操作符非 IN 莫属，答案一目了然。LIKE 后接正则表达式；!= 是其他程序语言常用的判断符号；BETWEEN 应和 AND 配合用于判断范围。",
            "knowledge_comment": "NOT IN 用于排除列表中的值。",
            "correct_answer": "NOT IN",
            "applicable_databases": ["MySQL", "SQL Server", "Oracle"]
        },
        {
            "question_id": 6,
            "question_text_before_options": "查询名字以\"张\"开头且名字有3个字的用户：SELECT * FROM users WHERE name LIKE ",
            "options": ["'张_'", "'张%'" ,"'张__'","'张*'"],
            "question_text_after_options": ";",
            "question_comment": "_ 是 LIKE 操作符中的通配符，代表单个任意字符。'张_' 表示以 \"张\" 开头，后面跟着1个任意字符的字符串；% 是通配符，代表零个或多个任意字符。'张%' 表示以 \"张\" 开头的任意字符串；在常见的主流关系型数据库（如 MySQL、SQL Server、Oracle、PostgreSQL 等）中，SELECT * FROM websites WHERE Name LIKE '张*' 均不适用，因为这些数据库在使用 LIKE 进行模糊匹配时，标准的通配符是 %（代表零个或多个任意字符）和 _（代表单个任意字符），而非 *。",
            "knowledge_comment": "_ 是 LIKE 操作符中的通配符，代表单个任意字符。'张__' 表示以 \"张\" 开头，后面跟着两个任意字符的字符串。",
            "correct_answer": "'张__'",
            "applicable_databases": ["MySQL", "SQL Server", "Oracle"]
        },
        {
            "question_id": 7,
            "question_text_before_options": "SELECT name, IF(stock > 0, ",
            "options": ["'有货'", "有货" ,"TRUE"],
            "question_text_after_options": ", '缺货') AS status FROM products;",
            "question_comment": "本题主要考察IF函数的使用。IF() 是一个条件判断函数，其语法为 IF(condition, value_if_true, value_if_false)。如果 condition 为真，则返回 value_if_true；否则返回 value_if_false。",
            "knowledge_comment": "IF 函数的第二个参数为条件为真时的返回值，需用引号包裹字符串。CASE WHEN 的条件判断语句在需要判断的情况较多时使用，简单的 Y/N 判断用IF即可。IF作为常用函数，使用方法应该牢记。对于简单的条件判断，一般来说，MySQL 用 IF，SQL Server 用 IIF，Oracle 用 CASE WHEN。",
            "correct_answer": "'有货'",
            "applicable_databases": ["MySQL"]
        },
        {
            "question_id": 7,
            "question_text_before_options": "SELECT name, ",
            "options": ["IF" ,"IFELSE", "IIF"],
            "question_text_after_options": "(stock > 0, '有货', '缺货') AS status FROM products;",
            "question_comment": "本题主要考察条件判断函数的使用。IF() 是 MySQL 中的一个条件判断函数，其语法为 IF(condition, value_if_true, value_if_false)，不适用于 SQL Server，因此排除；IFELSE 并不是一个可用的函数名，因此排除。",
            "knowledge_comment": "IIF 函数是 SQL Server 2012 及更高版本引入的，它是 IF...ELSE 逻辑的简洁表达方式，语法为 IIF(condition, true_value, false_value)。在 SQL Server 2012 及以上版本中，你可以使用 IIF 函数来替代 CASE 表达式实现条件判断，使代码更加简洁直观。对于简单的条件判断，一般来说，SQL Server 用 IIF，MySQL 用 IF，Oracle 用 CASE WHEN。",
            "correct_answer": "IIF",
            "applicable_databases": ["SQL Server"]
        },
        {
            "question_id": 8,
            "question_text_before_options": "查询3天前的订单：SELECT * FROM orders WHERE order_date >= ",
            "options": ["CURRENT_DATE - 3", "DATE_SUB(NOW(), INTERVAL 3 DAY)" ,"GETDATE() - 3","SYSDATE - 3"],
            "question_text_after_options": ";",
            "question_comment": "本题可使用排除法。CURRENT_DATE 的写法不对，CURRENT_DATE是函数名，后应加()，因此可以排除；GETDATE 是 SQL Server 中的函数，也可以排除。SYSDATE 的写法不对，SYSDATE 是函数名，后应加()，因此也可以排除。关于SYSDATE函数的更多介绍请参考：https://dev.mysql.com/doc/refman/9.3/en/date-and-time-functions.html#function_sysdate",
            "knowledge_comment": "MySQL 使用 DATE_SUB 和 INTERVAL 处理日期的减法计算。",
            "correct_answer": "DATE_SUB(NOW(), INTERVAL 3 DAY)",
            "applicable_databases": ["MySQL"]
        },
        {
            "question_id": 9,
            "question_text_before_options": "查询前5条记录：SELECT * FROM employees ",
            "options": ["LIMIT 5" ,"TOP 5", "WHERE ROW_NUMBER() <= 5", "WHERE ROWNUM <= 5"],
            "question_text_after_options": ";",
            "question_comment": "LIMIT 5 是 MySQL 的写法；TOP 5 是 SQL Server 的写法，但位置不再尾端；ROW_NUMBER() 是一个窗口函数，它需要结合 OVER 子句来指定排序规则，并不能直接在 WHERE 子句中使用。",
            "knowledge_comment": "在 Oracle 中，ROWNUM是一个伪列，用于表示结果集的行号。除了题目中的 WHERE ROWNUM <= 5 写法，从 Oracle 12c 开始，还可以这样写：SELECT * FROM employees ORDER BY employee_id OFFSET 0 ROWS FETCH NEXT 5 ROWS ONLY; 需要注意的是，ORDER BY 是必需的。",
            "correct_answer": "WHERE ROWNUM <= 5",
            "applicable_databases": ["Oracle"]
        },
        {
            "question_id": 9,
            "question_text_before_options": "查询前5条记录：SELECT * FROM employees ",
            "options": ["LIMIT 5" ,"TOP 5", "WHERE ROW_NUMBER() <= 5", "WHERE ROWNUM <= 5"],
            "question_text_after_options": ";",
            "question_comment": "TOP 5 是 SQL Server 的写法，但并不位于尾端；ROW_NUMBER() 是一个窗口函数，它需要结合 OVER 子句来指定排序规则，并不能直接在 WHERE 子句中使用；MySQL 不支持 ROWNUM 关键词。",
            "knowledge_comment": "在 MySQL 里，LIMIT 是一个常用的子句，用于限制查询结果返回的行数。",
            "correct_answer": "LIMIT 5",
            "applicable_databases": ["MySQL"]
        },
        {
            "question_id": 9,
            "question_text_before_options": "查询前5条记录：SELECT",
            "options": ["LIMIT" ,"TOP"],
            "question_text_after_options": " 5 * FROM employees;",
            "question_comment": "LIMIT 5 是 MySQL 的写法，用于限制查询结果返回的行数，位于查询语句的尾端。",
            "knowledge_comment": "TOP 5 是 SQL Server 的写法，用于限制查询结果返回的行数。除了题目中的写法：SELECT TOP 5 * FROM employees;，从 SQL Server 2012 版本开始，还可以这样写：SELECT * FROM employees ORDER BY employee_id OFFSET 0 ROWS FETCH NEXT 5 ROWS ONLY; 需要注意的是，ORDER BY 是必需的。",
            "correct_answer": "TOP",
            "applicable_databases": ["SQL Server"]
        },
        {
            "question_id": 10,
            "question_text_before_options": "将 NULL 替换为 \"未知\"：SELECT name, ",
            "options": ["ISNULL" ,"NVL" ,"IFNULL" ,"COALESCE"],
            "question_text_after_options": "(city, '未知') AS city FROM customers;",
            "question_comment": "本题可使用排除法。ISNULL 是 SQL Server 函数名，用来判断 NULL 值；NVL 是 Oracle 函数名，用来判断 NULL 值；COALESCE 函数的作用是返回参数列表中第一个非 NULL 的值。它接受多个参数，会按照从左到右的顺序依次检查这些参数，一旦遇到非 NULL 的值，就返回该值，若所有参数都是 NULL，则返回 NULL。使用 COALESCE 函数并不能完成本题的要求。",
            "knowledge_comment": "IFNULL 可用来判断 NULL 值，其语法为 IFNULL(column, value_if_null)。如果 column 值为 NULL，则返回 value_if_null。",
            "correct_answer": "IFNULL",
            "applicable_databases": ["MySQL"]
        },
        {
            "question_id": 10,
            "question_text_before_options": "将 NULL 替换为 \"未知\"：SELECT name, ",
            "options": ["ISNULL" ,"NVL" ,"IFNULL" ,"COALESCE"],
            "question_text_after_options": "(city, '未知') AS city FROM customers;",
            "question_comment": "本题可使用排除法。NVL 是 Oracle 函数名，用来判断 NULL 值；IFNULL 是 MSQL 函数名，用来判断 NULL 值；COALESCE 函数的作用是返回参数列表中第一个非 NULL 的值。它接受多个参数，会按照从左到右的顺序依次检查这些参数，一旦遇到非 NULL 的值，就返回该值，若所有参数都是 NULL，则返回 NULL。使用 COALESCE 函数并不能完成本题的要求。",
            "knowledge_comment": "ISNULL 可用来判断 NULL 值，其语法为 ISNULL(column, value_if_null)。如果 column 值为 NULL，则返回 value_if_null。",
            "correct_answer": "ISNULL",
            "applicable_databases": ["SQL Server"]
        },
        {
            "question_id": 10,
            "question_text_before_options": "将 NULL 替换为\"未知\"：SELECT name, ",
            "options": ["ISNULL" ,"NVL" ,"IFNULL" ,"COALESCE"],
            "question_text_after_options": "(city, '未知') AS city FROM customers;",
            "question_comment": "本题可使用排除法。ISNULL 是 SQL Server 函数名，用来判断 NULL 值；IFNULL 是 MSQL 函数名，用来判断 NULL 值；COALESCE 函数的作用是返回参数列表中第一个非 NULL 的值。它接受多个参数，会按照从左到右的顺序依次检查这些参数，一旦遇到非 NULL 的值，就返回该值，若所有参数都是 NULL，则返回 NULL。使用 COALESCE 函数并不能完成本题的要求。",
            "knowledge_comment": "NVL 可用来判断 NULL 值，其语法为 NVL(column, value_if_null)。如果 column 值为 NULL，则返回 value_if_null。",
            "correct_answer": "NVL",
            "applicable_databases": ["Oracle"]
        },
        {
            "question_id": 11,
            "question_text_before_options": "格式化日期为\"YYYY-MM-DD\"格式：SELECT DATE_FORMAT(order_date, '",
            "options": ["%Y-%m-%d" ,"yyyy-MM-dd" ,"YYYY-MM-DD" ,"YY-MM-DD"],
            "question_text_after_options": "') AS formatted_date FROM orders;",
            "question_comment": "DATE_FORMAT 函数用于将日期或日期时间值按照指定的格式进行格式化输出。其语法为 DATE_FORMAT(date, format)，其中 date 是要格式化的日期或日期时间值，format 是指定的输出格式。",
            "knowledge_comment": "%Y 代表四位年份，%m 代表两位月份，%d 代表两位日期。MySQL 还提供了很多其他格式说明符，如 %H 表示 24 小时制的小时，%i 表示分钟，%s 表示秒。感兴趣的话，可以多去官网了解。",
            "correct_answer": "%Y-%m-%d",
            "applicable_databases": ["MySQL"]
        },
        {
            "question_id": 11,
            "question_text_before_options": "格式化日期为\"YYYY-MM-DD\"格式：SELECT FORMAT(order_date, '",
            "options": ["%Y-%m-%d" ,"yyyy-MM-dd" ,"YYYY-MM-DD" ,"YY-MM-DD"],
            "question_text_after_options": "') AS formatted_date FROM orders;",
            "question_comment": "从 SQL Server 2012 版本开始，引入了 FORMAT 函数来实现日期格式化功能。FORMAT 函数更加通用，不仅可以处理日期类型，还能处理其他数据类型。其语法为 FORMAT(value, format [, culture])，其中 value 是要格式化的值，format 是指定的格式，culture 是可选的文化设置。",
            "knowledge_comment": "这里使用 yyyy 表示四位年份，MM 表示两位月份，dd 表示两位日期。最需要注意的就是大写小。",
            "correct_answer": "yyyy-MM-dd",
            "applicable_databases": ["SQL Server"]
        },
        {
            "question_id": 11,
            "question_text_before_options": "格式化日期为\"YYYY-MM-DD\"格式：SELECT TO_CHAR(order_date, '",
            "options": ["%Y-%m-%d" ,"yyyy-MM-dd" ,"YYYY-MM-DD" ,"YY-MM-DD"],
            "question_text_after_options": "') AS formatted_date FROM orders;",
            "question_comment": "在 Oracle 中，使用 TO_CHAR 函数来进行日期格式化。TO_CHAR 函数可以将日期、数字等数据类型转换为字符类型，并按照指定的格式输出。其语法为 TO_CHAR(date, format)，其中 date 是要格式化的日期，format 是指定的格式。",
            "knowledge_comment": "这里使用 YYYY 表示四位年份，MM 表示两位月份，DD 表示两位日期。最需要注意的就是大写小。",
            "correct_answer": "YYYY-MM-DD",
            "applicable_databases": ["Oracle"]
        }
    ],
    "4" : [
    {
        "question_id": 1,
        "question_text_before_options": "本年级所有学生按总分降序排名（相同总分排名一致，下一排名不跳过）：SELECT student_id, class_number, total_score, ",
        "options": ["ROW_NUMBER", "DENSE_RANK", "RANK", "NTILE"],
        "question_text_after_options": "() OVER (ORDER BY total_score DESC) AS ranking FROM student_scores;",
        "question_comment": "先分析题目，题目要求按总分排名，可以确定题目考查排序函数，ROW_NUMBER 和 NTILE 被排除。ROW_NUMBER 为结果集中的每一行分配一个唯一的行号，行号按照指定的排序顺序依次递增，且不会出现重复编号，常用于分页查询、筛选前 N 条记录等场景。NTILE 将结果集按照指定的数量分成若干个组，并为每一行分配一个组号，表示该行所在的组，常用于数据分析中的分桶操作，如将客户按消费金额分成不同等级的组，以便进行针对性的营销策略制定。再分析题目具体需求：相同总分排名一致，下一排名不跳过。RANK 也可为结果集中的行分配排名，当存在并列情况时，并列的行具有相同的排名，但后续排名会跳过相应的数字，因此被排除。",
        "knowledge_comment": "DENSE_RANK 为结果集中的行分配排名，当存在并列情况时，并列的行具有相同的排名，且后续排名是连续的，不会跳过任何数字。适用于需要连续排名，且并列情况不影响后续排名顺序的场景，如成绩排名等。",
        "correct_answer": "DENSE_RANK",
        "applicable_databases": ["MySQL", "SQL Server", "Oracle"]
    },    
    {
        "question_id": 2,
        "question_text_before_options": "SELECT student_id, exam_name, score, DENSE_RANK() OVER (",
        "options": ["GROUP BY", "PARTITION BY", "PART BY", "PARTITION ON"],
        "question_text_after_options": " exam_name ORDER BY score DESC) AS ranking FROM student_scores;",
        "question_comment": "GROUP BY 用于聚合查询的分组，而窗口函数中必须用 PARTITION BY 定义分区。因为都是分组，所以人们容易将两种\"分组\"概念混淆，要注意区分。PART BY 是一种错写，通常是因为对 PARTITION 单词的不熟悉导致的，单词多写几遍就记住了，要多用哦。PARTITION ON 也是一种错写，在窗口函数中，ORDER BY 用于排序，类似的 PARTITION BY 用来分区，可以一起记忆，都使用BY。",
        "knowledge_comment": "PARTITION BY 是唯一在窗口函数中定义分区的关键词。",
        "correct_answer": "PARTITION BY",
        "applicable_databases": ["MySQL", "SQL Server", "Oracle"]
    },
    {
        "question_id": 3,
        "question_text_before_options": "按部门分区，工资降序生成连续行号：SELECT name, department, salary, ROW_NUMBER() OVER (",
        "options": ["ORDER BY salary DESC PARTITION BY department", "PARTITION BY department ORDER BY salary DESC" ,"GROUP BY department ORDER BY salary DESC","PARTITION BY salary ORDER BY department"],
        "question_text_after_options": ") AS page_row FROM employees;",
        "question_comment": "PARTITION BY 子句用于将结果集按照指定的列进行分区。根据题目要求，按 department 列对 employees 表的数据进行分区，因此是 PARTITION BY department；ORDER BY 子句用于指定每个分区内的排序规则。我们按照 salary 列降序排序，即 ORDER BY salary DESC。因为 ORDER BY 用于指定分区的排序规则，所以要先有分区才能排序，因此 ORDER BY 子句需要在 PARTITION BY 子句之后。",
        "knowledge_comment": "PARTITION BY 子句用于将结果集按照指定的列进行分区。ORDER BY 子句用于指定每个分区内的排序规则。ORDER BY 子句顺序在 PARTITION BY 子句之后。",
        "correct_answer": "PARTITION BY department ORDER BY salary DESC",
        "applicable_databases": ["MySQL", "SQL Server", "Oracle"]
    },
    {
        "question_id": 4,
        "question_text_before_options": "计算每个员工按入职日期的累计工资总和：SELECT name, hire_date, salary, SUM(salary) OVER (ORDER BY hire_date ",
        "options": ["PARTITION BY department", "DESC" ,"ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW","RANGE BETWEEN 1 PRECEDING AND CURRENT ROW"],
        "question_text_after_options": ") AS total FROM employees;",
        "question_comment": "ORDER BY 子句顺序在 PARTITION BY 子句之后，排除一个错误答案；在计算累计工资总和时，我们通常需要按入职日期从早到晚（升序）排列来正确累加，而 DESC 是降序，会导致累计结果不符合逻辑；RANGE BETWEEN 1 PRECEDING AND CURRENT ROW 计算当前行和与当前行 hire_date 值相邻的前一行（逻辑范围）的累加值，因此无法实现\"从最早日期到当前日期\"的累计总和，仅计算相邻行的部分值。",
        "knowledge_comment": "ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW 这个子句表示从当前行之前的所有行（UNBOUNDED PRECEDING）到当前行（CURRENT ROW），这样就能实现累计求和。这样长的字句需要多使用才能记住。",
        "correct_answer": "ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW",
        "applicable_databases": ["MySQL", "SQL Server", "Oracle"]
    },
    {
        "question_id": 5,
        "question_text_before_options": "查询每个产品按销售日期的累计销售金额：SELECT product_id, sale_date, sale_amount, SUM(sale_amount) OVER (PARTITION BY product_id ORDER BY sale_date ",
        "options": ["ROWS", "RANGE" ,"LINES","COLUMNS"],
        "question_text_after_options": " BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS running_total FROM sales;",
        "question_comment": "RANGE 基于排序键的值确定范围，在此场景下不适用；LINES 和 COLUMNS 不是定义窗口范围的正确关键字。",
        "knowledge_comment": "ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW 按行的物理顺序，从分区的第一行到当前行进行累加，符合累计计算的需求。",
        "correct_answer": "ROWS",
        "applicable_databases": ["MySQL", "SQL Server", "Oracle"]
    },
    {
        "question_id": 6,
        "question_text_before_options": "查询每支股票最近三个交易日收盘价的总和：SELECT stock_id, trading_date, closing_price, SUM(closing_price) OVER (PARTITION BY stock_id ORDER BY trading_date ROWS BETWEEN 2 ",
        "options": ["PRECEDING", "FOLLOWING" ,"CURRENT","UNBOUNDED"],
        "question_text_after_options": " AND CURRENT ROW) AS sum_last_three FROM stock_prices;",
        "question_comment": "ROWS BETWEEN 2 PRECEDING AND CURRENT ROW 表示窗口范围是当前行和它前面的两行，正好是最近三个交易日；FOLLOWING 是往后的行；CURRENT 表述错误，；UNBOUNDED 通常与 PRECEDING 或 FOLLOWING 搭配表示无界的开始或结束，都不符合计算最近三个交易日总和的要求。",
        "knowledge_comment": "ROWS BETWEEN 只能使用以下几种取值来定义窗口范围：UNBOUNDED PRECEDING（表示窗口范围从当前分区的第一行开始）、CURRENT ROW（代表当前行）、n PRECEDING（意味着从当前行往前数 n 行）、n FOLLOWING（表示从当前行往后数 n 行）、UNBOUNDED FOLLOWING（表示窗口范围到当前分区的最后一行结束）。BETWEEN 关键字后的起始位置应该在逻辑上先于 AND 关键字后的结束位置。如果写成不符合逻辑顺序的形式，数据库通常会返回错误，因为它违背了窗口定义的基本逻辑：窗口的起始点应该在结束点之前。",
        "correct_answer": "PRECEDING",
        "applicable_databases": ["MySQL", "SQL Server", "Oracle"]
    },
    {
        "question_id": 7,
        "question_text_before_options": "查询每个客户在订单日期前三日内的平均订单金额：SELECT customer_id, order_date, order_amount, AVG(order_amount) OVER (PARTITION BY customer_id ORDER BY order_date ",
        "options": ["ROWS", "RANGE" ,"LINES","COLUMNS"],
        "question_text_after_options": " BETWEEN INTERVAL 3 DAY PRECEDING AND CURRENT ROW) AS avg_three_days FROM orders;",
        "question_comment": "RANGE BETWEEN INTERVAL 3 DAY PRECEDING AND CURRENT ROW 表示窗口范围是当前行日期往前三天到当前行日期，符合计算前三日平均订单金额的逻辑；ROWS BETWEEN 只能使用以下几种取值来定义窗口范围：UNBOUNDED PRECEDING、CURRENT ROW、n PRECEDING、n FOLLOWING、UNBOUNDED FOLLOWING。题目 BETWEEN 后方是 INTERVAL 3 DAY PRECEDING ，所以 ROWS 在此场景下不适用；LINES 和 COLUMNS 不是定义窗口范围的正确关键字。",
        "knowledge_comment": "RANGE BETWEEN 依据排序键的值来确定范围，只要排序键的值满足条件，对应的行就会被包含在窗口内。在 RANGE BETWEEN 子句中，定义窗口范围可以有多种写法：UNBOUNDED PRECEDING（表示从当前分区的第一行开始作为窗口范围的起始位置）、CURRENT ROW（代表当前行，既可以作为起始位置也可以作为结束位置）、n PRECEDING（n 表示一个数值，n PRECEDING 意味着从当前行往前数 n 个与排序键值相关的行作为窗口范围的起始位置）、n FOLLOWIN（n 为一个数值，n FOLLOWING 表示从当前行往后数 n 个与排序键值相关的行作为窗口范围的结束位置）、UNBOUNDED FOLLOWING（表示窗口范围到当前分区的最后一行结束）、使用 INTERVAL 关键字（当排序键是日期或时间类型时，可以使用 INTERVAL 来指定一个时间范围）。",
        "correct_answer": "RANGE",
        "applicable_databases": ["MySQL", "Oracle"]
    },
    {
        "question_id": 8,
        "question_text_before_options": "查询每个员工工资与上一名员工的差值：SELECT name, salary, salary - ",
        "options": ["LAG(salary, 1)", "LEAD(salary, 1)" ,"FIRST_VALUE(salary)","LAST_VALUE(salary)"],
        "question_text_after_options": " OVER (ORDER BY salary DESC) AS diff FROM employees;",
        "question_comment": "LEAD 是一个窗口函数，与 LAG 相反，它用于在结果集中从当前行向后偏移指定的行数，并获取该行指定列的值。LEAD(salary, 1) 表示从当前行向后偏移 1 行，获取那一行的 salary 值。FIRST_VALUE 是一个窗口函数，用于返回窗口内第一行指定列的值。无论当前行是哪一行，它总是返回窗口内第一行的 salary 值。LAST_VALUE 是一个窗口函数，用于返回窗口内最后一行指定列的值。默认情况下，窗口范围是从第一行到当前行，所以它返回的是当前窗口内最后一行（通常就是当前行）的 salary 值。因此都不符合题目要求的每个员工工资与上一名员工的差值。",
        "knowledge_comment": "LAG 是一个窗口函数，用于在结果集中从当前行向前偏移指定的行数，并获取该行指定列的值。LAG(salary, 1) 表示从当前行向前偏移 1 行，获取那一行的 salary 值。",
        "correct_answer": "LAG(salary, 1)",
        "applicable_databases": ["MySQL", "SQL Server", "Oracle"]

    },
    {
        "question_id": 9,
        "question_text_before_options": "计算每个部门内员工的工资百分比排名：SELECT name, department, salary, ",
        "options": ["RANK", "PERCENT_RANK" ,"CUME_DIST","DENSE_RANK"],
        "question_text_after_options": "() OVER (PARTITION BY department ORDER BY salary DESC) AS percent_rank FROM employees;",
        "question_comment": "RANK 函数为结果集中的每一行分配一个排名。当存在并列值时，并列的行将被赋予相同的排名，并且下一个排名会跳过相应的数量。它返回的是具体的排名数字，而非百分比排名，不符合本题要求。CUME_DIST 函数计算当前行的累积分布值，即小于或等于当前行值的行数占分区内总行数的比例。虽然也是计算相对位置，但计算方式与 PERCENT_RANK 不同，它得到的是累积分布比例，并非百分比排名，不符合本题要求。DENSE_RANK 函数与 RANK 类似，为结果集中的每一行分配一个排名。但当存在并列值时，并列的行被赋予相同的排名，下一个排名是连续的，不会跳过。同样的，它返回的是具体的排名数字，不是百分比排名，不符合本题要求。",
        "knowledge_comment": "PERCENT_RANK 函数计算当前行的百分比排名。其计算公式为 (当前行的排名 - 1) / (分区内总行数 - 1)，结果是一个介于 0 到 1 之间的小数，表示当前行在分区内的相对位置。",
        "correct_answer": "PERCENT_RANK",
        "applicable_databases": ["MySQL", "SQL Server", "Oracle"]
    },
    {
        "question_id": 10,
        "question_text_before_options": "将每个部门的员工按工资分为4个等级：SELECT name, department, salary, NTILE(4) OVER (PARTITION BY department ORDER BY salary DESC) AS bucket FROM employees; 如果部门有7名员工，每个桶（组）的人数分布：",
        "options": ["2,2,2,1", "1,2,2,2" ,"3,2,2,0","4,3,0,0"],
        "question_text_after_options": "。",
        "question_comment": "NTILE(4) 函数会将每个 department 分区内按照 salary 降序排列后的员工数据平均分成 4 个桶（组），并为每一行分配一个桶编号（1 - 4）存储在 bucket 列中。要将 7 行数据划分为 4 个桶，计算每个桶平均分配的行数为 7 ÷ 4 = 1（向下取整），余数为 7 % 4 = 3。这意味着会先给前 3 个桶各多分配 1 行，分配情况：前 3 个桶：每个桶有 1 + 1 = 2 行。第 4 个桶：有 1 行。",
        "knowledge_comment": "NTILE 函数的作用是将有序的数据集合划分为指定数量的桶（组），并为每一行分配一个桶编号。当员工数量不能被指定的桶数整除时，NTILE 会尽量平均分配，前面的桶会比后面的桶多分配一些行。",
        "correct_answer": "2,2,2,1",
        "applicable_databases": ["MySQL", "SQL Server", "Oracle"]
    }
    ],
    "5" : [
        {
            "question_id": 1,
            "question_text_before_options": "合并姓氏和名字：SELECT ",
            "options": ["last_name || ' ' || first_name", "last_name + ' ' + first_name" ,"CONCAT(last_name, ' ', first_name)","JOIN(last_name, ' ', first_name)"],
            "question_text_after_options": " AS full_name FROM employees;",
            "question_comment": "默认 || 是逻辑 OR 运算符，若需使用 ||，需通过 SET sql_mode = 'PIPES_AS_CONCAT'; 来启用；+ 是算术运算符，字符串会转为 0（如 'John' + ' ' 结果为 0）；JOIN 是用于表连接的关键字，并非字符串函数。",
            "knowledge_comment": "CONCAT 函数可以接受任意数量的参数，若参数中有 NULL，则结果为 NULL。",
            "correct_answer": "CONCAT(last_name, ' ', first_name)",
            "applicable_databases": ["MySQL"]
            },
            {
            "question_id": 1,
            "question_text_before_options": "合并姓氏和名字的最佳写法：SELECT ",
            "options": ["last_name || ' ' || first_name", "last_name + ' ' + first_name" ,"CONCAT(last_name, ' ', first_name)","JOIN(last_name, ' ', first_name)"],
            "question_text_after_options": " AS full_name FROM employees;",
            "question_comment": "SQL Server 不支持 || 作为字符串连接符；2012+ 版本支持 CONCAT函数，NULL 值会自动转为空字符串，因为版本限制，此选项非最佳解；JOIN 是用于表连接的关键字，并非字符串函数。",
            "knowledge_comment": "使用 + 连接字符串是主流写法，若参数中有 NULL，则结果为 NULL，所以有时需配合 ISNULL 来处理 NULL 值情况。",
            "correct_answer": "last_name + ' ' + first_name",
            "applicable_databases": ["SQL Server"]
            },
            {
            "question_id": 1,
            "question_text_before_options": "合并姓氏和名字：SELECT ",
            "options": ["last_name || ' ' || first_name", "last_name + ' ' + first_name" ,"CONCAT(last_name, ' ', first_name)","JOIN(last_name, ' ', first_name)"],
            "question_text_after_options": " AS full_name FROM employees;",
            "question_comment": "+ 是算术运算符；Oracle 中的 CONCAT 函数仅支持两参数，如果希望合并姓名，需嵌套使用：CONCAT(CONCAT(last_name, ' '), first_name)；JOIN 是用于表连接的关键字，并非字符串函数。",
            "knowledge_comment": "使用 || 连接字符串是标准用法。",
            "correct_answer": "last_name || ' ' || first_name",
            "applicable_databases": ["Oracle"]
            },
            {
            "question_id": 2,
            "question_text_before_options": "不能从邮箱中提取域名的是：SELECT ",
            "options": ["SUBSTRING", "SUBSTR" ,"LEFT","MID"],
            "question_text_after_options": "(email, INSTR(email, '@') + 1) AS domain FROM users;",
            "question_comment": "INSTR(str, substr)：返回 substr 在 str 中第一次出现的位置（位置从 1 开始）。SUBSTRING(str, position)：从 position 位置开始截取字符串（位置从 1 开始）。SUBSTR(str, pos)：从 pos 位置开始截取字符串（位置从 1 开始），是 SUBSTRING 的同义词。MID(str, pos)：从 pos 位置开始截取字符串（位置从 1 开始），是 SUBSTRING 的同义词。假设 email 为 john@example.com，INSTR(email, '@') 返回 5，SUBSTRING(email, 6)、SUBSTR(email, 6)和MID(email, 6) 都会返回 example.com。",
            "knowledge_comment": "LEFT(str, length)：截取字符串左边 length 个字符。假设 email 为 john@example.com，INSTR(email, '@') 返回 5，LEFT(email, 6) 返回 john@e，结果错误。",
            "correct_answer": "LEFT",
            "applicable_databases": ["MySQL"]
            },
            {
            "question_id": 2,
            "question_text_before_options": "从邮箱中提取域名：SELECT ",
            "options": ["SUBSTRING", "SUBSTR" ,"LEFT","MID"],
            "question_text_after_options": "(email, CHARINDEX('@', email) + 1, LEN(email)) AS domain FROM users;",
            "question_comment": "CHARINDEX('@', email)：返回 @ 在 email 中的位置（位置从 1 开始）。SQL Server 不支持 SUBSTR 和 MID 函数。LEFT(str, length)：截取字符串左边 length 个字符。假设 email 为 john@example.com，INSTR(email, '@') 返回 5，LEFT(email, 6) 返回 john@e，结果错误。",
            "knowledge_comment": "SUBSTRING(email, pos, LEN(email))：从 pos 开始截取到字符串末尾。假设 email 为 john@example.com，CHARINDEX('@', email) 返回 5，SUBSTRING(email, 6, 16) 返回 example.com。",
            "correct_answer": "SUBSTRING",
            "applicable_databases": ["SQL Server"]
            },
            {
            "question_id": 2,
            "question_text_before_options": "从邮箱中提取域名：SELECT ",
            "options": ["SUBSTRING", "SUBSTR" ,"LEFT","MID"],
            "question_text_after_options": "(email, INSTR(email, '@') + 1) AS domain FROM users;",
            "question_comment": "INSTR(str, substr)：返回 substr 在 str 中第一次出现的位置（位置从 1 开始）。Oracle 不支持 SUBSTRING、LEFT 和 MID 函数。SUBSTRING 是 MySQL 中的函数，与 Oracle 的 SUBSTR 功能相同，只是名称不同。",
            "knowledge_comment": "SUBSTR(str, position)：从 position 位置开始截取字符串（位置从 1 开始）。假设 email 为 john@example.com，INSTR(email, '@') 返回 5，SUBSTR(email, 6) 返回 example.com。",
            "correct_answer": "SUBSTR",
            "applicable_databases": ["Oracle"]
            },
            {
            "question_id": 3,
            "question_text_before_options": "不能隐藏手机号中间四位的是：SELECT CONCAT(LEFT(phone, 3), '****', MID(phone",
            "options": [", 4", ", -4", ", 8, 4", ", -4, 4", "FROM -4", "FROM -4 FOR 4"],
            "question_text_after_options": ") AS masked_phone FROM users;",
            "question_comment": "MID(phone, 4) 返回从第4位开始的字符串，举例：MID('13812345678', 4) → 12345678，显然没能隐藏中间四位。其他结果均返回后四位字符串。MID(str, pos) 中 pos 为负数时，表示从字符串末尾开始计数。",
            "knowledge_comment": "MID 函数的基本语法是：MID(str,pos,len)。但它还有几种不同的使用方法：MID(str,pos)、MID(str FROM pos)、MID(str,pos,len) 和 MID(str FROM pos FOR len)。最推荐的写法就是 MID(str,pos,len)，避免兼容性问题。如果想要看每一个语法的详情，请查看此网站：https://www.modb.pro/db/62106",
            "correct_answer": ", 4",
            "applicable_databases": ["MySQL"]
            },
            {
            "question_id": 3,
            "question_text_before_options": "不能隐藏手机号中间四位的是：SELECT CONCAT(LEFT(phone, 3), '****', ",
            "options": ["RIGHT(phone, 4)", "SUBSTRING(phone, LEN(phone) - 3, 4)" ,"SUBSTRING(phone, -4, 4)","REVERSE(LEFT(REVERSE(phone), 4))"],
            "question_text_after_options": ") AS masked_phone FROM users;",
            "question_comment": "RIGHT(phone, 4) 直接提取右侧 4 个字符。SUBSTRING(phone, LEN(phone) - 3, 4) 从 LEN(phone) - 3 位置开始截取4位字符串。REVERSE(LEFT(REVERSE(phone), 4))，通过反转字符串→左取前 4 位→再反转回来，逻辑正确但冗余。除非必要，否则不推荐这样写。",
            "knowledge_comment": "SUBSTRING(phone, -4, 4) 错误的原因是 SQL Server 不支持负索引，会报错。",
            "correct_answer": "SUBSTRING(phone, -4, 4)",
            "applicable_databases": ["SQL Server"]
            },
            {
            "question_id": 3,
            "question_text_before_options": "不能隐藏手机号中间四位的是：SELECT CONCAT(LEFT(phone, 3), '****', ",
            "options": ["RIGHT(phone, 4)", "SUBSTR(phone, -4)" ,"SUBSTR(phone, LENGTH(phone) - 3, 4)","REVERSE(SUBSTR(REVERSE(phone), 1, 4))"],
            "question_text_after_options": ") AS masked_phone FROM users;",
            "question_comment": "SUBSTR 支持负索引，SUBSTR(phone, -4) 直接从右侧取 4 位。SUBSTR(phone, LENGTH(phone) - 3, 4) 通过 LENGTH(phone) - 3 计算起始位置。REVERSE(SUBSTR(REVERSE(phone), 1, 4)) 借助 REVERSE 函数实现，逻辑正确但冗余。除非必要，否则不推荐这样写。",
            "knowledge_comment": "Oracle 不支持 RIGHT 函数。正如它不支持 LEFT 和 MID 函数一样。",
            "correct_answer": "RIGHT(phone, 4)",
            "applicable_databases": ["Oracle"]
            },
            {
            "question_id": 4,
            "question_text_before_options": "从文件路径中提取文件名：SELECT ",
            "options": ["SUBSTRING_INDEX(path, '/', -1)", "RIGHT(path, CHARINDEX('/', REVERSE(path)) - 1)" ,"SUBSTRING(path, LEN(path) - CHARINDEX('/', REVERSE(path)) + 2, 100)","REVERSE(SUBSTRING(REVERSE(path), 1, CHARINDEX('/', REVERSE(path)) - 1))"],
            "question_text_after_options": " AS filename FROM files;",
            "question_comment": "CHARINDEX 函数是 SQL Server中的函数，除了选项1，其他选项均被排除。",
            "knowledge_comment": "SUBSTRING_INDEX(str, delimiter, count)：从 str 中按 delimiter 分割，取第 count 个部分。count=-1 表示从右侧开始取第一个部分（即最后一个 / 后的内容）。",
            "correct_answer": "SUBSTRING_INDEX(path, '/', -1)",
            "applicable_databases": ["MySQL"]
            },
            {
            "question_id": 4,
            "question_text_before_options": "从文件路径中提取文件名：SELECT ",
            "options": ["SUBSTRING_INDEX(path, '/', -1)", "RIGHT(path, CHARINDEX('/', REVERSE(path)) - 1)" ,"SUBSTRING(path, LEN(path) - CHARINDEX('/', REVERSE(path)) + 2, 100)","REVERSE(SUBSTRING(REVERSE(path), 1, CHARINDEX('/', REVERSE(path)) - 1))"],
            "question_text_after_options": " AS filename FROM files;",
            "question_comment": "SUBSTRING_INDEX 是 MySQL 特有的函数，用于根据分隔符截取字符串部分，选项1排除。RIGHT(path, CHARINDEX('/', REVERSE(path)) - 1) 无法正确提取文件名，因为它错误地计算了截取长度。SUBSTRING(path, LEN(path) - CHARINDEX('/', REVERSE(path)) + 2, 100) 的思路正确，但需注意：替换固定长度（100）为 LEN(path)，处理无 / 的情况（通过 CASE 判断）。",
            "knowledge_comment": "SQL Server 中需通过 反转 + 截取 + 再反转 或 定位最后一个 / 的位置来实现从文件路径中提取文件名这件事，以确保兼容性和健壮性。",
            "correct_answer": "REVERSE(SUBSTRING(REVERSE(path), 1, CHARINDEX('/', REVERSE(path)) - 1))",
            "applicable_databases": ["SQL Server"]
            },
            {
            "question_id": 4,
            "question_text_before_options": "从文件路径中提取文件名：SELECT ",
            "options": ["SUBSTRING_INDEX(path, '/', -1)", "RIGHT(path, CHARINDEX('/', REVERSE(path)) - 1)" ,"SUBSTR(path, INSTR(path, '/', -1) + 1)","SUBSTRING(path, INSTR(path, '/', -1) + 1)"],
            "question_text_after_options": " AS filename FROM files;",
            "question_comment": "SUBSTRING_INDEX 是 MySQL 特有的函数，用于根据分隔符截取字符串部分，选项1排除。CHARINDEX 函数是 SQL Server中的函数，选项2被排除。SUBSTRING 在 MySQL 和 SQL Server 中直接支持，而 Oracle 不支持，选项4被排除。",
            "knowledge_comment": "SUBSTR(str, start [, length]) 的起始位置start支持正数（从左到右）和负数（从右到左）。",
            "correct_answer": "SUBSTR(path, INSTR(path, '/', -1) + 1)",
            "applicable_databases": ["Oracle"]
            },
            {
            "question_id": 5,
            "question_text_before_options": "移除电话号码中的非数字字符-：SELECT ",
            "options": ["SUBSTITUTE", "REPLACE" ,"REPLACE_WITH","SUBSTRING"],
            "question_text_after_options": "(phone, '-', '') AS clean_phone;",
            "question_comment": "SUBSTITUTE 是 Oracle 特有的函数。REPLACE_WITH 函数并不存在。SUBSTRING(str, start [, length])：从 start 位置开始截取长度为 length 的字符串（位置从 1 开始），不能实现题目所求是其一。就算要用，第二和第三参数也应该是数字。",
            "knowledge_comment": "REPLACE 函数用于在字符串中替换指定的子串，其基本语法为：REPLACE(string, old_substring, new_substring)。将 string 中所有的 old_substring 替换为 new_substring，并返回替换后的新字符串。",
            "correct_answer": "REPLACE",
            "applicable_databases": ["MySQL", "SQL Server"]
            },
            {
            "question_id": 5,
            "question_text_before_options": "移除电话号码中的非数字字符-：SELECT ",
            "options": ["SUBSTITUTE", "REPLACE" ,"REPLACE_WITH","SUBSTRING"],
            "question_text_after_options": "(phone, '-') AS clean_phone;",
            "question_comment": "REPLACE 函数接受3个参数，它的语法是：REPLACE(string, old_substring, new_substring)。将 string 中所有的 old_substring 替换为 new_substring，并返回替换后的新字符串。REPLACE_WITH 函数并不存在。SUBSTRING(str, start [, length])：如果 length 省略，则从 start 位置开始截取到尾端的字符串（位置从 1 开始），不能实现题目所求是其一。就算要用，第二个参数也应该是数字。",
            "knowledge_comment": "SUBSTITUTE 函数的语法是 SUBSTITUTE(string, old_substring, [new_substring])，当省略 new_substring 时，SUBSTITUTE 函数会删除字符串中所有的 old_substring，这是 SUBSTITUTE 函数的一个独特功能。REPLACE 函数要实现相同功能，需要将 new_substring 显式地指定为空字符串。",
            "correct_answer": "SUBSTITUTE",
            "applicable_databases": ["Oracle"]
            },
            {
            "question_id": 6,
            "question_text_before_options": "从 JSON 字段中提取 username：SELECT ",
            "options": ["JSON_EXTRACT", "JSON_VALUE" ,"EXTRACT"],
            "question_text_after_options": "(user_info, '$.username') AS username FROM profiles;",
            "question_comment": "JSON_VALUE 是 SQL Server 和 Oracle 中的函数。EXTRACT 函数的语法是 EXTRACT(unit FROM date_value)，用于从日期中提取想要的部分，比如年、月、日等。",
            "knowledge_comment": "JSON_EXTRACT 函数的语法为 JSON_EXTRACT(json_doc, path)，是标准函数，若路径不存在返回 NULL。也可简写 -> ，针对本题，简写形式为 SELECT user_info->'$.username' AS username FROM profiles; 虽然 -> 操作符更简洁，但结果类型可能不同（需用 ->> 强制转为字符串）。",
            "correct_answer": "JSON_EXTRACT",
            "applicable_databases": ["MySQL"]
            },
            {
            "question_id": 6,
            "question_text_before_options": "从 JSON 字段中提取 username：SELECT ",
            "options": ["JSON_EXTRACT", "JSON_VALUE" ,"EXTRACT"],
            "question_text_after_options": "(user_info, '$.username') AS username FROM profiles;",
            "question_comment": "JSON_EXTRACT 是 MySQL 中的函数。SQL Server 中不存在 EXTRACT 函数。",
            "knowledge_comment": "JSON_VALUE 函数的语法为 JSON_VALUE(json_expr, path)，专门用于提取标量值（字符串、数字等）。若路径不存在，返回 NULL（可通过 IS NOT NULL 过滤）。嵌套路径写法为：JSON_VALUE(user_info, '$.address.city')。",
            "correct_answer": "JSON_VALUE",
            "applicable_databases": ["SQL Server"]
            },
            {
            "question_id": 6,
            "question_text_before_options": "从 JSON 字段中提取 username：SELECT ",
            "options": ["JSON_EXTRACT", "JSON_VALUE" ,"EXTRACT"],
            "question_text_after_options": "(user_info, '$.username' RETURNING VARCHAR2(100)) AS username FROM profiles;",
            "question_comment": "JSON_EXTRACT 是 MySQL 中的函数。不存在 EXTRACT 函数。EXTRACT 函数的语法是 EXTRACT(unit FROM date_value)，用于从日期中提取想要的部分，比如年、月、日等。",
            "knowledge_comment": "JSON_VALUE 函数的语法为 JSON_VALUE(json_column, path RETURNING type)，返回类型是可选的，若路径不存在，默认返回 NULL（可通过 DEFAULT ... ON ERROR 修改）。因此本题也可写作：SELECT JSON_VALUE(user_info, '$.username') AS username FROM profiles; 但建议用 RETURNING 指定类型，避免类型错误。",
            "correct_answer": "JSON_VALUE",
            "applicable_databases": ["Oracle"]
            },
            {
            "question_id": 7,
            "question_text_before_options": "create_time 是 DATE 类型，将 create_time（格式：2023-09-01）转为\"2023年09月01日\"：SELECT DATE_FORMAT(create_time, '",
            "options": ["%Y年%m月%d日", "%y年%m月%d日", "%y年%M月%d日", "%y年%M月%D日"],
            "question_text_after_options": "') FROM table;",
            "question_comment": "%Y指4字年份(2023)；%yY指2字年份(23)；%m指2字月份（09）；%M指月份的英文全称（September）；%d指2字日子（01）；%D指日子跟着序数词（1st）。",
            "knowledge_comment": "DATE_FORMAT 函数的语法为 DATE_FORMAT(date, format)，format中能够填写的简写是确定的，详情请参考此网站：https://www.w3schools.com/sql/func_mysql_date_format.asp",
            "correct_answer": "%Y年%m月%d日",
            "applicable_databases": ["MySQL"]
            },
            {
            "question_id": 7,
            "question_text_before_options": "create_time 是 DATE 类型，将 create_time（格式：2023-10-01）转为\"2023年10月01日\"：SELECT FORMAT(create_time, '",
            "options": ["d","D","N","G","C"],
            "question_text_after_options": "', 'zh-cn') FROM table;",
            "question_comment": "自己去这个网站上填入每个选项看看结果吧：https://www.w3schools.com/sql/trysqlserver.asp?filename=trysql_func_sqlserver_format2",
            "knowledge_comment": "FORMAT 函数的语法为 FORMAT(value , format [, culture])，关于 FORMAT 函数的解释请看这篇文章：https://learn.microsoft.com/en-us/sql/t-sql/functions/format-transact-sql?view=sql-server-ver16",
            "correct_answer": "D",
            "applicable_databases": ["SQL Server"]
            },
            {
            "question_id": 7,
            "question_text_before_options": "create_time 是 DATE 类型，将 create_time（格式：2023-10-01）转为\"2023年10月01日\"：SELECT TO_CHAR(create_time, '",
            "options": ["%Y年%m月%d日", "YYYY\"年\"MM\"月\"DD\"日\"", "YYYY年MM月DD日", "yyyy年MM月dd日"],
            "question_text_after_options": "') FROM table;",
            "question_comment": "Oracle 使用 YYYY（年）、MM（月）、DD（日）格式，用双引号 \"\" 包裹非日期格式字符来避免错误解释。",
            "knowledge_comment": "关键在于要使用双引号 \"\" 包裹非日期格式字符（如 \"年\"\"月\"\"日\"），否则 Oracle 可能将其解释为日期元素。",
            "correct_answer": "YYYY\"年\"MM\"月\"DD\"日\"",
            "applicable_databases": ["Oracle"]
            },
            {
            "question_id": 8,
            "question_text_before_options": "SELECT ",
            "options": ["YEAR", "EXTRACT", "DATEPART"],
            "question_text_after_options": "(start_date) AS year FROM table;",
            "question_comment": "EXTRACT 函数的语法是 EXTRACT(unit FROM date_value)，想要获得年份则需写作 EXTRACT(YEAR FROM start_date)。DATEPART  是 SQL Server 中的函数。",
            "knowledge_comment": "YEAR 函数的语法为 YEAR(date_value)，输入可以是日期字符串、DATE 类型或 DATETIME 类型。若输入为 NULL 或无效日期则返回 NULL。YEAR(start_date) 的等效函数是 EXTRACT(YEAR FROM start_date)。",
            "correct_answer": "YEAR",
            "applicable_databases": ["MySQL"]
            },
            {
            "question_id": 8,
            "question_text_before_options": "SELECT ",
            "options": ["YEAR", "EXTRACT", "DATEPART"],
            "question_text_after_options": "(start_date) AS year FROM table;",
            "question_comment": "SQL Server 中不存在 EXTRACT 函数。DATEPART 函数的语法是 DATEPART(unit, start_date)，想要获得年份则需写作 DATEPART(YEAR, start_date)。",
            "knowledge_comment": "YEAR 函数的语法为 YEAR(date_value)，输入可以是日期字符串、DATE 类型或 DATETIME 类型。若输入为 NULL 或无效日期则返回 NULL。YEAR(start_date) 的等效函数是 DATEPART(YEAR, start_date)。",
            "correct_answer": "YEAR",
            "applicable_databases": ["SQL Server"]
            },
            {
            "question_id": 8,
            "question_text_before_options": "SELECT ",
            "options": ["YEAR", "EXTRACT", "DATEPART", "TO_CHAR"],
            "question_text_after_options": "(YEAR FROM TO_DATE(start_date, 'YYYY-MM-DD')) AS year FROM table; ",
            "question_comment": "Oracle 中不存在 YEAR 和 DATEPART 函数。TO_CHAR(start_date, 'YYYY') 也可从日期中提取年份，和 EXTRACT 类似，date_column（本题中为 start_date）如果是。字符串类型（如 VARCHAR2），在 Oracle 中需先将其转换为 DATE 类型。",
            "knowledge_comment": "EXTRACT 函数的语法是 EXTRACT(unit FROM date_value)，用于从日期中提取想要的部分，比如年、月、日等。另可看出 start_date 列是字符串类型（如 VARCHAR2），在 Oracle 中需先将其转换为 DATE 类型，再使用 EXTRACT 函数。如果 start_date 是 DATE 类型，写作 EXTRACT(YEAR FROM start_date)即可。",
            "correct_answer": "EXTRACT",
            "applicable_databases": ["Oracle"]
            },
            {
            "question_id": 9,
            "question_text_before_options": "将部门员工姓名合并为逗号分隔字符串（如：Alice,Bob,Carol）：SELECT department, ",
            "options": ["GROUP_CONCAT(name)", "GROUP_CONCAT(name, ',')" ,"STRING_AGG(name, ',')","LISTAGG(name, ',')"],
            "question_text_after_options": " AS members FROM employees GROUP BY department;",
            "question_comment": "GROUP_CONCAT(name, ',')错误的原因是语法错误。如果希望得到题目要求，可以写作：GROUP_CONCAT(name) 或 GROUP_CONCAT(name SEPARATOR ',')，因为,是默认分隔符，建议直接写 GROUP_CONCAT(name)。STRING_AGG 和 LISTAGG 在 MySQL 中均不支持。MySQL 使用 GROUP_CONCAT 实现相同功能。",
            "knowledge_comment": "GROUP_CONCAT 函数的语法为 GROUP_CONCAT([DISTINCT] expr [ORDER BY expr ASC/DESC] [SEPARATOR str_val])，默认分隔符为逗号 ,。可通过 SET SESSION group_concat_max_len = 102400; 调整最大长度。",
            "correct_answer": "GROUP_CONCAT(name)",
            "applicable_databases": ["MySQL"]
            },
            {
            "question_id": 9,
            "question_text_before_options": "将部门员工姓名合并为逗号分隔字符串（如：Alice,Bob,Carol）：SELECT department, ",
            "options": ["CONCAT", "GROUP_CONCAT" ,"STRING_AGG","LISTAGG"],
            "question_text_after_options": "(name, ',') AS members FROM employees GROUP BY department;",
            "question_comment": "CONCAT 是用于拼接多个字符串参数（横向拼接），而 STRING_AGG 是用于将多行数据聚合为单个字符串（纵向拼接）。GROUP_CONCAT 和 LISTAGG 在 SQL Server 中均不支持。",
            "knowledge_comment": "STRING_AGG 是用于将多行数据按组拼接成单个字符串的聚合函数，在 SQL Server 2017+ 中支持。语法为：STRING_AGG(input_expression, separator) [WITHIN GROUP (ORDER BY order_expression [ASC|DESC])]。input_expression：要拼接的列或表达式，separator 是分隔符（如 ', '、'|'），WITHIN GROUP (ORDER BY)：可选，指定拼接顺序。",
            "correct_answer": "STRING_AGG",
            "applicable_databases": ["SQL Server"]
            },
            {
            "question_id": 9,
            "question_text_before_options": "将部门员工姓名合并为逗号分隔字符串（如：Alice,Bob,Carol）：SELECT department, ",
            "options": ["CONCAT", "GROUP_CONCAT" ,"STRING_AGG","LISTAGG"],
            "question_text_after_options": "(name, ',') WITHIN GROUP (ORDER BY name) AS members FROM employees GROUP BY department;",
            "question_comment": "CONCAT 是用于拼接2个字符串参数（横向拼接），仅支持两个参数，若需拼接多个字符串，需嵌套使用或改用 || 操作符。而 LISTAGG 是用于将多行数据聚合为单个字符串（纵向拼接）。GROUP_CONCAT 和 STRING_AGG 在 SQL Server 中均不支持。",
            "knowledge_comment": "Oracle 11g+ 支持 LISTAGG。LISTAGG 函数的语法为 LISTAGG(expression, separator) [WITHIN GROUP (ORDER BY sort_expression [ASC|DESC])]。支持排序（通过 WITHIN GROUP），WITHIN GROUP (ORDER BY ...) 是可选的，但省略后拼接顺序不确定。强烈建议保留。默认忽略 NULL 值，如需处理 NULL 需用 NVL(name, 'NULL') 显式处理。",
            "correct_answer": "LISTAGG",
            "applicable_databases": ["Oracle"]
            },
            {
            "question_id": 10,
            "question_text_before_options": "不能够匹配邮箱格式的是：WHERE email ",
            "options": ["REGEXP", "REGEXP_LIKE" ,"RLIKE","LIKE"],
            "question_text_after_options": " '^[A-Za-z0-9._%+-]+@[A-Za-z0-9-]+(\\.[A-Za-z]{2,})+$';",
            "question_comment": "RLIKE 是早期 MySQL 版本引入的操作符，语法类似于 LIKE，但使用正则表达式而非简单通配符。为了与其他 SQL 数据库（如 PostgreSQL）保持一致，MySQL 后来添加了 REGEXP 作为 RLIKE 的别名。两者在功能、语法和性能上没有任何区别。它们都是用于正则表达式匹配的操作符。LIKE 使用简单通配符而非正则表达式。",
            "knowledge_comment": "REGEXP_LIKE 是 Oracle 中的函数，既然是函数，而非操作符，那么应该后跟()，本题显然不应使用函数。此外， MySQL 并不支持 REGEXP_LIKE 函数。",
            "correct_answer": "REGEXP_LIKE",
            "applicable_databases": ["MySQL"]
            },
            {
            "question_id": 10,
            "question_text_before_options": "匹配邮箱格式：WHERE email ",
            "options": ["REGEXP", "REGEXP_LIKE" ,"RLIKE","LIKE"],
            "question_text_after_options": "('^[A-Za-z0-9._%+-]+@[A-Za-z0-9-]+(\\.[A-Za-z]{2,})+$', 'i');",
            "question_comment": "REGEXP 和 RLIKE 是 MySQL 中的操作符，Oracle 并不支持。LIKE 使用简单通配符而非正则表达式。",
            "knowledge_comment": "REGEXP_LIKE 是 Oracle 数据库中用于正则表达式匹配的函数，支持复杂的模式匹配和高级文本处理。基本语法：REGEXP_LIKE(source_string, pattern [, match_parameter])，source_string 是待匹配的字符串。pattern 是正则表达式模式。match_parameter（可选）是控制匹配行为的标志。",
            "correct_answer": "REGEXP_LIKE",
            "applicable_databases": ["Oracle"]
            }
    ],
    "6" : [
        {
            "question_id": 1,
            "question_text_before_options": "INSERT ",
            "options": ["IN", "TO", "INTO", "INTO TABLE"],
            "question_text_after_options": " students (id, name, age) VALUES (1, '张三', 20);",
            "question_comment": "固定语法：INSERT INTO。记住最简单的方法就是每天去数据库里加一行，加 30 天，我不信记不住。",
            "knowledge_comment": "使用 INSERT INTO 语法，无需 TABLE 关键字。",
            "correct_answer": "INTO",
            "applicable_databases": ["MySQL", "SQL Server", "Oracle"]
        },
        {
            "question_id": 2,
            "question_text_before_options": "插入记录时使用默认值：INSERT INTO orders (order_id, amount, create_time) VALUES (1001, 500.0, ",
            "options": ["DEFAULT", "NULL" ,"AUTO","NOW()"],
            "question_text_after_options": ");",
            "question_comment": "NULL 表示插入空值。若 create_time 列被定义为 NOT NULL 且无默认值，则会报错；若允许 NULL，则插入 NULL。SQL 标准中无 AUTO 关键字用于时间戳列。AUTO 通常与自增主键（如 AUTO_INCREMENT）相关，但不适用于时间列。NOW() 主要用于返回执行时刻的时间戳，格式：'YYYY-MM-DD HH:MM:SS'，比如 '2025-05-12 14:30:00'。但题目要求的是使用默认值，默认值并不一定是当前日期和时间，不可妄自揣测。",
            "knowledge_comment": "DEFAULT 关键字表示使用列定义的默认值。若 create_time 列定义了默认值（如 DEFAULT CURRENT_TIMESTAMP），则会自动填充当前时间；若未定义，则取决于列是否允许 NULL。",
            "correct_answer": "DEFAULT",
            "applicable_databases": ["MySQL"]
        },
        {
            "question_id": 2,
            "question_text_before_options": "插入记录时使用默认值：INSERT INTO orders (order_id, amount, create_time) VALUES (1001, 500.0, ",
            "options": ["DEFAULT", "NULL" ,"AUTO","NOW()"],
            "question_text_after_options": ");",
            "question_comment": "NULL 表示插入空值。若 create_time 列被定义为 NOT NULL 且无默认值，则会报错；若允许 NULL，则插入 NULL。SQL 标准中无 AUTO 关键字用于时间戳列。AUTO 通常与自增主键（如 MySQL 的 AUTO_INCREMENT）相关，但不适用于时间列。NOW() 是 MySQL 函数，SQL Server 及 Oracle不支持。",
            "knowledge_comment": "DEFAULT 关键字表示使用列定义的默认值。若 create_time 列定义了默认值（如 DEFAULT CURRENT_TIMESTAMP），则会自动填充当前时间；若未定义，则取决于列是否允许 NULL。",
            "correct_answer": "DEFAULT",
            "applicable_databases": ["SQL Server", "Oracle"]
        },
        {
            "question_id": 3,
            "question_text_before_options": "将 2023 年订单数据插入历史表：INSERT ",
            "options": ["INTO order_history VALUES SELECT * FROM orders WHERE EXTRACT(YEAR FROM order_date) = 2023", "order_history SELECT * FROM orders WHERE EXTRACT(YEAR FROM order_date) = 2023" , "INTO order_history SELECT * FROM orders WHERE EXTRACT(YEAR FROM order_date) = 2023", "VALUES SELECT * FROM orders WHERE EXTRACT(YEAR FROM order_date) = 2023 INTO order_history"],
            "question_text_after_options": ";",
            "question_comment": "选项1混淆了手动插入指定值和从其他表导入的语法，错误的在查询语句前加了 VALUES。部分数据库（如 SQLite）允许省略INTO的特性，但主流数据库（MySQL、SQL Server、Oracle）均要求INSERT INTO。选项4混淆了手动插入指定值和从其他表导入的语法，错误的在查询语句前加了 VALUES。且 INTO destination_table 的顺序不对。",
            "knowledge_comment": "从其他表导入数据的语法是：INSERT INTO destination_table SELECT col1, col2 FROM source_table; 当目标表 destination_table 和 来源表 source_table 结构完全相同时，可写作：INSERT INTO destination_table SELECT * FROM source_table。为了性能考虑，大数据量时采用分批插入或禁用索引。",
            "correct_answer": "INTO order_history SELECT * FROM orders WHERE EXTRACT(YEAR FROM order_date) = 2023",
            "applicable_databases": ["MySQL", "Oracle"]
        },
        {
            "question_id": 3,
            "question_text_before_options": "将 2023 年订单数据插入历史表：INSERT INTO order_history ",
            "options": ["INTO order_history VALUES SELECT * FROM orders WHERE DATEPART(YEAR, order_date) = 2023", "order_history SELECT * FROM orders WHERE DATEPART(YEAR, order_date) = 2023" , "INTO order_history SELECT * FROM orders WHERE DATEPART(YEAR, order_date) = 2023", "VALUES SELECT * FROM orders WHERE DATEPART(YEAR, order_date) = 2023 INTO order_history"],
            "question_text_after_options": ";",
            "question_comment": "选项1混淆了手动插入指定值和从其他表导入的语法，错误的在查询语句前加了 VALUES。部分数据库（如 SQLite）允许省略INTO的特性，但主流数据库（MySQL、SQL Server、Oracle）均要求INSERT INTO。选项4混淆了手动插入指定值和从其他表导入的语法，错误的在查询语句前加了 VALUES。且 INTO destination_table 的顺序不对。",
            "knowledge_comment": "从其他表导入数据的语法是：INSERT INTO destination_table SELECT col1, col2 FROM source_table; 当目标表 destination_table 和 来源表 source_table 结构完全相同时，可写作：INSERT INTO destination_table SELECT * FROM source_table。为了性能考虑，大数据量时采用分批插入或禁用索引。",
            "correct_answer": "INTO order_history SELECT * FROM orders WHERE DATEPART(YEAR, order_date) = 2023",
            "applicable_databases": ["SQL Server"]
        },
        {
            "question_id": 4,
            "question_text_before_options": "向 students 表一次性插入三条记录：INSERT INTO students (id, name, age) ",
            "options": ["VALUES (1, '张三', 20), (2, '李四', 22), (3, '王五', 25)", "VALUES (1, '张三', 20), VALUES (2, '李四', 22), VALUES (3, '王五', 25)" , "SELECT 1, '张三', 20 FROM DUAL UNION ALL SELECT 2, '李四', 22 FROM DUAL UNION ALL SELECT 3, '王五', 25 FROM DUAL"],
            "question_text_after_options": ";",
            "question_comment": "多行插入时直接用逗号分隔值列表，无需重复 VALUES，选项2错。选项3是 Oracle 一次性插入多条记录的语法。",
            "knowledge_comment": "一次性插入多条记录的语法：INSERT INTO table VALUES (), (), ()",
            "correct_answer": "VALUES (1, '张三', 20), (2, '李四', 22), (3, '王五', 25)",
            "applicable_databases": ["MySQL", "SQL Server"]
        },
        {
            "question_id": 4,
            "question_text_before_options": "向 students 表一次性插入三条记录：INSERT INTO students (id, name, age) ",
            "options": ["VALUES (1, '张三', 20), (2, '李四', 22), (3, '王五', 25)", "VALUES (1, '张三', 20), VALUES (2, '李四', 22), VALUES (3, '王五', 25)" , "SELECT 1, '张三', 20 FROM DUAL UNION ALL SELECT 2, '李四', 22 FROM DUAL UNION ALL SELECT 3, '王五', 25 FROM DUAL"],
            "question_text_after_options": ";",
            "question_comment": "选项1是 MySQL 和 SQL Server 一次性插入多条记录的语法。选项2和选项1类似，但使用了多个 VALUES，MySQL 和 SQL Server 一次性插入多条记录的语法：INSERT INTO table VALUES (), (), ()，无需重复 VALUES，选项2错。",
            "knowledge_comment": "一次性插入多条记录的语法：INSERT INTO table SELECT ... UNION ALL ...",
            "correct_answer": "SELECT 1, '张三', 20 FROM DUAL UNION ALL SELECT 2, '李四', 22 FROM DUAL UNION ALL SELECT 3, '王五', 25 FROM DUAL",
            "applicable_databases": ["Oracle"]
        },
        {
            "question_id": 5,
            "question_text_before_options": "插入用户，若 email 已存在则忽略：INSERT INTO users (id, email, name) VALUES (1, 'zhangsan@example.com', '张三') ",
            "options": ["ON DUPLICATE KEY UPDATE", "ON DUPLICATE KEY SET", "ON CONFLICT (email)", "IGNORE"],
            "question_text_after_options": " id = id;",
            "question_comment": "选项2的 SET 字样错误。在 MySQL 中，ON DUPLICATE KEY UPDATE 是忽略重复的语法。ON CONFLICT (email) DO NOTHING 是 PostgreSQL 忽略重复的做法，此句指定冲突列，和冲突行为。INSERT IGNORE 简单，但会忽略所有错误，不合题意。如需使用，可参考：INSERT IGNORE INTO users (id, email, name) VALUES (1, 'zhangsan@example.com', '张三');",
            "knowledge_comment": "ON DUPLICATE KEY UPDATE 的判断逻辑依赖于表的唯一约束（Unique Constraint）或主键（Primary Key），而非显式在语句中指定列。因此若 email 已存在（需在 email 列上有唯一索引），则执行 UPDATE id = id（实际上不更新任何内容，相当于忽略）。",
            "correct_answer": "ON DUPLICATE KEY UPDATE",
            "applicable_databases": ["MySQL"]
        },
        {
            "question_id": 5,
            "question_text_before_options": "插入用户，若 email 已存在则忽略：INSERT INTO users (id, email, name) VALUES (1, 'zhangsan@example.com', '张三') ",
            "options": ["ON DUPLICATE KEY UPDATE id = id", "ON DUPLICATE KEY SET id = id", "ON CONFLICT (email) DO NOTHING", "IGNORE"],
            "question_text_after_options": ";",
            "question_comment": "ON DUPLICATE KEY UPDATE 的判断逻辑依赖于表的唯一约束（Unique Constraint）或主键（Primary Key），而非显式在语句中指定列。因此若 email 已存在（需在 email 列上有唯一索引），则执行 UPDATE id = id（实际上不更新任何内容，相当于忽略）。选项2的 SET 字样错误。在 MySQL 中，ON DUPLICATE KEY UPDATE 是忽略重复的语法。INSERT IGNORE 简单，但会忽略所有错误，不合题意。如需使用，可参考：INSERT IGNORE INTO users (id, email, name) VALUES (1, 'zhangsan@example.com', '张三');",
            "knowledge_comment": "ON CONFLICT (email) DO NOTHING 是 PostgreSQL 忽略重复的做法，此句指定冲突列，和冲突行为。",
            "correct_answer": "ON CONFLICT (email) DO NOTHING",
            "applicable_databases": ["PostgreSQL"]
        },
        {
            "question_id": 6,
            "question_text_before_options": "插入数据并返回新生成的 ID：INSERT INTO products (name, price) VALUES ('手机', 3000.0); SELECT ",
            "options": ["LAST_INSERT_ID()", "INSERTED.id", "NEW.id", "RETURNING id"],
            "question_text_after_options": ";",
            "question_comment": "INSERTED 是 SQL Server 的语法，用于 OUTPUT 子句或触发器中引用插入的数据。MySQL 中无此关键字。NEW 是 MySQL 触发器中的特殊变量，用于引用新插入 / 更新的数据。不能在普通 SQL 语句中直接使用。旧版 MySQL（8.0.21 之前）不支持 RETURNING 语法。新版 MySQL（8.0.21+）支持 RETURNING，但需在 INSERT 语句中使用，而非单独的 SELECT，MySQL 8.0.21+ 正确语法：INSERT INTO products (name, price) VALUES ('手机', 3000.0) RETURNING id; 即直接在 INSERT 后返回。题目中 INSERT 和 SELECT 是分开的两条语句，因此 RETURNING 不适用。",
            "knowledge_comment": "LAST_INSERT_ID() 是 MySQL 内置函数，返回当前会话中最后一次插入操作生成的自增 ID（适用于 AUTO_INCREMENT 列）。LAST_INSERT_ID() 仅对当前会话有效，不同会话的插入操作互不影响。若插入多行，仅返回第一行的 ID。",
            "correct_answer": "LAST_INSERT_ID()",
            "applicable_databases": ["MySQL"]
        },
        {
            "question_id": 6,
            "question_text_before_options": "插入数据并返回新生成的 ID：INSERT INTO products (name, price) OUTPUT ",
            "options": ["INSERTED.id", "NEW.id", "GENERATED_KEYS.id", "id"],
            "question_text_after_options": " VALUES ('手机', 3000.0);",
            "question_comment": "SQL Server 不支持 NEW 关键字。NEW 通常用在 MySQL、PostgreSQL 的触发器（Trigger）中引用新插入的行，但不能直接在 INSERT 语句中使用。GENERATED_KEYS 是 JDBC API 中的概念（如 Statement.getGeneratedKeys()），并非 SQL 标准语法，不能直接在 SQL 语句中使用。在 SQL Server 的 OUTPUT 子句中，必须明确指定 INSERTED. 或 DELETED. 前缀，用于引用插入 / 删除操作的临时表。直接写 id 会导致 SQL Server 无法识别该列的来源，从而抛出语法错误。",
            "knowledge_comment": "OUTPUT 子句规则：必须使用 INSERTED. 或 DELETED. INSERTED 代表引用插入操作后的新行。DELETED 代表引用删除操作前的旧行（用于 DELETE 或 UPDATE）。",
            "correct_answer": "INSERTED.id",
            "applicable_databases": ["SQL Server"]
        },
        {
            "question_id": 6,
            "question_text_before_options": "插入数据并返回新生成的 ID：DECLARE v_id NUMBER; BEGIN INSERT INTO products (name, price) ",
            "options": ["OUTPUT id", "SELECT SCOPE_IDENTITY()", "RETURNING id", "RETURNING id INTO v_id"],
            "question_text_after_options": "; END;",
            "question_comment": "OUTPUT 是 SQL Server 的语法，Oracle 不支持。SCOPE_IDENTITY() 是 SQL Server 的函数，用于返回当前会话的自增 ID。Oracle 的 RETURNING 必须配合 INTO 使用。",
            "knowledge_comment": "返回自增 ID 的正确语法：RETURNING column INTO variable，Oracle 使用 RETURNING ... INTO 语法将生成的 id 存入变量。Oracle 的 RETURNING 必须配合 INTO 使用，需配合 PL/SQL 变量，且不支持直接返回结果集。",
            "correct_answer": "RETURNING id INTO v_id",
            "applicable_databases": ["Oracle"]
        },
        {
            "question_id": 6,
            "question_text_before_options": "插入数据并返回新生成的 ID：INSERT INTO products (name, price) ",
            "options": ["OUTPUT id", "SELECT CURRVAL('products_id_seq')", "RETURNING id", "RETURNING id INTO v_new_id"],
            "question_text_after_options": " VALUES ('手机', 3000.0);",
            "question_comment": "OUTPUT 是 SQL Server 的语法，PostgreSQL 不支持。ETURNING ... INTO 是 Oracle/PLpgSQL 的语法，在纯 SQL 中无效。CURRVAL 返回当前会话中最近一次 NEXTVAL 的值，所以如果未在当前会话中调用 NEXTVAL，会报错。且 CURRVAL 可能返回其他会话的值，并不可靠。",
            "knowledge_comment": "PostgreSQL 使用 RETURNING 子句直接返回插入后的列值。",
            "correct_answer": "RETURNING id",
            "applicable_databases": ["PostgreSQL"]
        },
        {
            "question_id": 7,
            "question_text_before_options": "高效插入 1000 条测试数据：WITH ",
            "options": ["RECURSIVE", "ITERATIVE", "LOOP", "CTE"],
            "question_text_after_options": " nums AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM nums WHERE n < 1000 ) INSERT INTO test_data (id, value) SELECT n, CONCAT('Data-', n) FROM nums;",
            "question_comment": "ITERATIVE 不是 SQL 标准关键字，部分编程语言（如 Python）中使用该术语表示迭代，但 SQL 中无此用法。LOOP 是过程化 SQL（如 PL/SQL、T-SQL）中的循环结构，用于编写存储过程，与 CTE 语法无关。CTE 是 Common Table Expression（公用表表达式）的缩写，不是 SQL 关键字。SQL 中不需要显式写 CTE。正确语法为 WITH RECURSIVE ...，而非 WITH CTE ...。",
            "knowledge_comment": "RECURSIVE 是启用递归 CTE 的关键字，必须紧跟在 WITH 之后。递归 CTE 的语法是：WITH RECURSIVE nums AS ( 递归逻辑...) SELECT ...; 递归 CTE 可能导致性能问题，特别是深度递归时。建议设置合理的终止条件，并使用 SET max_recursion_depth = N; 限制递归深度。递归 CTE 的默认限制是 1000 层，因此在生成 1 到 1000 的序列时，无需显式设置 max_recursion_depth。",
            "correct_answer": "RECURSIVE",
            "applicable_databases": ["MySQL"]
        },
        {
            "question_id": 7,
            "question_text_before_options": "高效插入 1000 条测试数据：WITH ",
            "options": ["RECURSIVE", "ITERATIVE", "LOOP", "CTE"],
            "question_text_after_options": " nums AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM nums WHERE n < 1000 ) INSERT INTO test_data (id, value) SELECT n, 'Data-' || n::text FROM nums;",
            "question_comment": "ITERATIVE 不是 SQL 标准关键字，部分编程语言（如 Python）中使用该术语表示迭代，但 SQL 中无此用法。LOOP 是过程化 SQL（如 PL/SQL、T-SQL）中的循环结构，用于编写存储过程，与 CTE 语法无关。CTE 是 Common Table Expression（公用表表达式）的缩写，不是 SQL 关键字。SQL 中不需要显式写 CTE。正确语法为 WITH RECURSIVE ...，而非 WITH CTE ...。",
            "knowledge_comment": "RECURSIVE 是启用递归 CTE 的关键字，必须紧跟在 WITH 之后。递归 CTE 的语法是：WITH RECURSIVE nums AS ( 递归逻辑...) SELECT ...; 递归深度无默认层数限制，但受系统内存和堆栈大小约束。",
            "correct_answer": "RECURSIVE",
            "applicable_databases": ["PostgreSQL"]
        },
        {
            "question_id": 7,
            "question_text_before_options": "高效插入 1000 条测试数据：WITH nums AS ( SELECT 1 AS n  UNION ALL  SELECT n + 1  FROM nums  WHERE n < 1000) INSERT INTO test_data (id, value) SELECT n, 'Data-' + CAST(n AS VARCHAR(10)) FROM nums",
            "options": ["RECURSIVE" ,"WITH RECURSIVE", "LIMIT 1000", "OPTION (MAXRECURSION 1000)"],
            "question_text_after_options": ";",
            "question_comment": "SQL Server 不使用 RECURSIVE 关键字，直接通过 WITH 定义 CTE。RECURSIVE 是 MySQL/PostgreSQL 的关键字，WITH RECURSIVE 是 MySQL/PostgreSQL 的语法，SQL Server 中会报错。LIMIT 是 MySQL 的语法，SQL Server 中需用 TOP 或 OFFSET/FETCH。",
            "knowledge_comment": "SQL Server 必须显式指定递归深度，默认递归深度为 100，需通过 OPTION (MAXRECURSION 1000) 允许递归到 1000 层。如果 OPTION (MAXRECURSION n) 中的 n 为 0，则表示无限制。",
            "correct_answer": "OPTION (MAXRECURSION 1000)",
            "applicable_databases": ["SQL Server"]
        },
        {
            "question_id": 7,
            "question_text_before_options": "正确使用递归查询生成 1 到 1000 的序列：INSERT INTO test_data (id, value) SELECT LEVEL, 'Data-' || LEVEL FROM DUAL CONNECT BY ",
            "options": ["LEVEL <= 1000", "PRIOR LEVEL = LEVEL + 1" , "NOCYCLE LEVEL = LEVEL + 1", "LEVEL = PRIOR LEVEL + 1 AND LEVEL <= 1000"],
            "question_text_after_options": ";",
            "question_comment": "选项1缺少递归关系定义（如 LEVEL = PRIOR LEVEL + 1），Oracle 无法确定如何生成下一行，会导致循环错误。PRIOR LEVEL = LEVEL + 1 表示当前行的 LEVEL 比父行小 1，导致生成倒序序列（如 1000, 999, ..., 1）。NOCYCLE 用于处理循环，但LEVEL = LEVEL + 1 是逻辑矛盾（永远不成立），导致无限循环。NOCYCLE 仅抑制错误，但无法生成有效序列。",
            "knowledge_comment": "通过 LEVEL = PRIOR LEVEL + 1 定义递归关系：当前行的 LEVEL 比父行大 1（生成正序），并通过 LEVEL <= 1000 终止，确保生成 1 到 1000。CONNECT BY 语法结构：SELECT ... FROM table_name CONNECT BY [NOCYCLE] condition START WITH initial_condition; PRIOR 关键字用于引用父行的值。START WITH：可选，指定递归起点（本例中 FROM DUAL 隐含起点为 1）。在 Oracle 中使用 CONNECT BY 时，必须同时定义递归关系（如 LEVEL = PRIOR LEVEL + 1）和终止条件（如 LEVEL <= 1000）。",
            "correct_answer": "LEVEL = PRIOR LEVEL + 1 AND LEVEL <= 1000",
            "applicable_databases": ["Oracle"]
        },
        {
            "question_id": 8,
            "question_text_before_options": "向 logs 表插入 JSON 格式日志：INSERT INTO logs (log_data) VALUES (",
            "options": ["'{\"user_id\": 101, \"action\": \"login\"}'", "JSON '{\"user_id\": 101, \"action\": \"login\"}'", "JSON_OBJECT('user_id', 101, 'action', 'login')", "CAST('{\"user_id\": 101, \"action\": \"login\"}' AS JSON)"],
            "question_text_after_options": ");",
            "question_comment": "选项1未显式指定 JSON 类型，虽然 MySQL 允许直接插入字符串到 JSON 列，但不验证格式，可能导致存储非法 JSON。选项2 JSON '...' 是 PostgreSQL 语法，MySQL 不支持。选项4的 CAST 在 MySQL 中不用于 JSON 类型转换。",
            "knowledge_comment": "JSON_OBJECT 是 MySQL 构造 JSON 的标准函数，JSON_OBJECT 自动构造合法 JSON，并验证格式。",
            "correct_answer": "JSON_OBJECT('user_id', 101, 'action', 'login')",
            "applicable_databases": ["MySQL"]
        },
        {
            "question_id": 8,
            "question_text_before_options": "向 logs 表插入 JSON 格式日志（log_data 为 NVARCHAR(MAX) 类型）：INSERT INTO logs (log_data) VALUES (",
            "options": ["'{\"user_id\": 101, \"action\": \"login\"}'", "JSON '{\"user_id\": 101, \"action\": \"login\"}'", "JSON_OBJECT('user_id', 101, 'action', 'login')", "JSON_MODIFY('{}', '$.user_id', 101, '$.action', 'login')"],
            "question_text_after_options": ");",
            "question_comment": "JSON '...' 是 PostgreSQL 语法，SQL Server 不支持。JSON_OBJECT 是 MySQL/Oracle 函数，SQL Server 无此函数。JSON_MODIFY 用于修改已有 JSON，不能直接构造完整 JSON。",
            "knowledge_comment": "SQL Server 不强制要求 NVARCHAR 列存储合法 JSON，因此可直接将字符串存储为 JSON，但需手动确保格式合法。可以用 ISJSON 函数来验证合法性，一个插入前验证的举例：IF ISJSON('{\"user_id\": 101}') = 1 INSERT INTO logs VALUES ('{\"user_id\": 101}');",
            "correct_answer": "'{\"user_id\": 101, \"action\": \"login\"}'",
            "applicable_databases": ["SQL Server"]
        },
        {
            "question_id": 8,
            "question_text_before_options": "向 logs 表插入 JSON 格式日志（log_data 为 JSON 类型）：INSERT INTO logs (log_data) VALUES (",
            "options": ["'{\"user_id\": 101, \"action\": \"login\"}'", "JSON '{\"user_id\": 101, \"action\": \"login\"}'", "JSON_OBJECT('user_id' VALUE 101, 'action' VALUE 'login')", "CAST('{\"user_id\": 101, \"action\": \"login\"}' AS JSON)"],
            "question_text_after_options": ");",
            "question_comment": "选项1未指定 JSON 类型，直接插入字符串到 JSON 列，Oracle 会存储为普通文本，失去 JSON 索引能力。JSON '...' 是 PostgreSQL 语法，Oracle 不支持。Oracle 不支持 CAST(... AS JSON) 语法。",
            "knowledge_comment": "JSON_OBJECT 是 Oracle 构造 JSON 的标准函数。JSON_OBJECT 自动验证 JSON 格式，生成合法 JSON 对象，并支持索引优化。",
            "correct_answer": "",
            "applicable_databases": ["Oracle"]
        },
        {
            "question_id": 8,
            "question_text_before_options": "向 logs 表插入 JSON 格式日志最推荐的方式是：INSERT INTO logs (log_data) VALUES (",
            "options": ["'{\"user_id\": 101, \"action\": \"login\"}'", "jsonb '{\"user_id\": 101, \"action\": \"login\"}'", "{\"user_id\": 101, \"action\": \"login\"}", "CAST('{\"user_id\": 101, \"action\": \"login\"}' AS JSON)"],
            "question_text_after_options": ");",
            "question_comment": "选项1未指定 JSON 类型，PostgreSQL 默认将其视为 text，可能导致后续查询异常。选项3缺少引号，PostgreSQL 无法识别为合法 JSON 或文本。选项4的 CAST 生成 json 类型而非 jsonb，且效率较低（jsonb 为二进制存储）。",
            "knowledge_comment": "jsonb '...' 是 PostgreSQL 构造 JSONB 对象的标准语法，jsonb '...' 显式构造 JSONB 对象，确保类型正确且支持索引。在 PostgreSQL 中插入 JSON 时，始终使用 jsonb '{}' 语法，确保类型正确且充分利用 JSONB 的优势。构造 JSONB 的方法：1. 直接构造 jsonb '{\"key\": \"value\"}' 2. 函数构造 to_jsonb(row('value')) 3. 强制类型转换 '{\"key\": \"value\"}'::jsonb",
            "correct_answer": "jsonb '{\"user_id\": 101, \"action\": \"login\"}'",
            "applicable_databases": ["PostgreSQL"]
        }
    ],
    "7" : [
        {
            "question_id": 1,
            "question_text_before_options": "",
            "options": ["SELECT", "INSERT", "UPDATE", "DELETE"],
            "question_text_after_options": " products SET price = price * 1.1 WHERE category = 'Electronics';",
            "question_comment": "看到 SET 关键字就知道，这条语句是在更新表中的数据。SELECT 用于查询数据，不能用于修改数据。INSERT 用于向表中插入新的数据行，语法为 INSERT INTO table_name (column1, column2, ...) VALUES (value1, value2, ...)，与更新已有数据的操作不符。DELETE 用于从表中删除数据行，语法为 DELETE FROM table_name WHERE condition，与修改数据值的目的不一致。",
            "knowledge_comment": "UPDATE 是 SQL 中用于修改表中已有数据的关键字，结合 SET 子句指定更新的列和值，WHERE 子句筛选要更新的行，符合题目中修改 products 表中价格的需求。",
            "correct_answer": "UPDATE",
            "applicable_databases": ["MySQL", "SQL Server", "Oracle"]
        },
        {
            "question_id": 2,
            "question_text_before_options": "UPDATE employees ",
            "options": ["TO", "SET", "COLUMN", "MODIFY"],
            "question_text_after_options": " salary = 8000 WHERE emp_id = 101;",
            "question_comment": "TO 通常用于 ALTER TABLE 语句（如 ALTER COLUMN）或赋值操作（如 SELECT ... INTO），但不在 UPDATE 语句中直接使用。COLUMN 是用于定义表结构的关键字（如 CREATE TABLE 或 ALTER TABLE），不能用于 UPDATE 语句。MODIFY 是 Oracle 和 MySQL 中用于修改表结构的关键字（如 ALTER TABLE MODIFY COLUMN），不能直接用于更新数据。",
            "knowledge_comment": "SET 是 UPDATE 语句中用于指定要更新的列及其新值的关键字。在 SQL 中，UPDATE 语句的标准语法为：UPDATE table_name SET column1 = value1, column2 = value2, ... WHERE condition;",
            "correct_answer": "SET",
            "applicable_databases": ["MySQL", "SQL Server", "Oracle"]
        },
        {
            "question_id": 3,
            "question_text_before_options": "同时更新工资和部门：UPDATE employees SET salary = 8000, ",
            "options": ["department", "SET department", "COLUMN department", "MODIFY department"],
            "question_text_after_options": " = '技术部' WHERE emp_id = 101;",
            "question_comment": "SET 关键字在 UPDATE 语句中已经使用过一次来开始设置更新的列和值，不需要再次使用 SET 来更新 department 列，这种写法是错误的。UPDATE 语句中直接使用列名来指定要更新的列，不需要 COLUMN 关键字，所以该选项错误。MODIFY 关键字通常用于修改表结构中列的定义，而不是在 UPDATE 语句中用于更新列的值，在 UPDATE 语句中使用 MODIFY 是错误的语法。",
            "knowledge_comment": "在 UPDATE 语句中，要同时更新多个列，直接在 SET 关键字后列出要更新的列及其对应的值，用逗号分隔。所以 UPDATE employees SET salary = 8000, department = '技术部' WHERE emp_id = 101; 是正确的语法。",
            "correct_answer": "department",
            "applicable_databases": ["MySQL", "SQL Server", "Oracle"]
        },
        {
            "question_id": 4,
            "question_text_before_options": "根据 departments 表的预算，更新 employees 表中对应部门员工的薪资上限：UPDATE employees e ",
            "options": ["LEFT JOIN", "CROSS JOIN", "INNER JOIN", "NATURAL JOIN"],
            "question_text_after_options": " departments d ON e.department_id = d.id SET e.max_salary = d.budget * 0.8;",
            "question_comment": "使用 LEFT JOIN 时，若部门不存在，d.budget 为 NULL，会导致 e.max_salary 被设为 NULL。CROSS JOIN 生成笛卡尔积，会导致数据混乱。NATURAL JOIN 按同名列自动关联，可能导致非预期关联。",
            "knowledge_comment": "INNER JOIN 仅更新 departments 中存在的部门员工，因此正确。如果觉得理解困难，可以去条件判断专栏做更多练习。",
            "correct_answer": "INNER JOIN",
            "applicable_databases": ["MySQL", "SQL Server", "Oracle"]
        },
        {
            "question_id": 5,
            "question_text_before_options": "将 employees 表中每个经理的薪资设为其直接下属的平均薪资：UPDATE employees m SET salary = ( SELECT AVG(salary) FROM employees WHERE manager_id = m.",
            "options": ["id", "manager_id", "employee_id", "department_id"],
            "question_text_after_options": ");",
            "question_comment": "若表主键为 id，则正确，但题目中主键为 employee_id。manager_id = m.manager_id 会筛选当前经理的同级，而非下属。department_id 与层级关系无关，manager_id = m.department_id 会产生啼笑皆非的后果。",
            "knowledge_comment": "子查询通过 manager_id = m.employee_id 筛选当前经理的下属。",
            "correct_answer": "employee_id",
            "applicable_databases": ["MySQL", "SQL Server", "Oracle"]
        },
        {
            "question_id": 6,
            "question_text_before_options": "若工龄超过5年，重置年假为15天，否则保持原值：UPDATE employees SET annual_leave = ",
            "options": ["15", "CASE WHEN years_of_service > 5 THEN 15 ELSE annual_leave END", "IFNULL(annual_leave, 15)", "DECODE(years_of_service, >5, 15)"],
            "question_text_after_options": " WHERE years_of_service > 5;",
            "question_comment": "直接写15会将所有员工的年假强制设为 15 天，而忽略工龄条件，导致错误。IFNULL(annual_leave, 15) 仅处理 annual_leave 为 NULL 的情况，无法根据工龄判断。DECODE是 Oracle 特有的简化版CASE，但选项出现语法错误。正确应为 DECODE(SIGN(years_of_service-5), 1, 15, annual_leave)），且其他数据库不支持。",
            "knowledge_comment": "使用 CASE 表达式的逻辑是：若years_of_service > 5，则将annual_leave设为 15 天；否则保持原值（ELSE annual_leave）。除了 CASE 表达式，还可以使用这个更易读的写法：UPDATE employees SET annual_leave = IF(years_of_service > 5, 15, annual_leave);",
            "correct_answer": "CASE WHEN years_of_service > 5 THEN 15 ELSE annual_leave END",
            "applicable_databases": ["MySQL"]
        },
        {
            "question_id": 6,
            "question_text_before_options": "若工龄超过5年，重置年假为15天，否则保持原值：UPDATE employees SET annual_leave = ",
            "options": ["15", "CASE WHEN years_of_service > 5 THEN 15 ELSE annual_leave END", "ISNULL(annual_leave, 15)", "DECODE(years_of_service, >5, 15)"],
            "question_text_after_options": " WHERE years_of_service > 5;",
            "question_comment": "直接写15会将所有员工的年假强制设为 15 天，而忽略工龄条件，导致错误。ISNULL(annual_leave, 15) 仅处理 annual_leave 为 NULL 的情况，无法根据工龄判断。DECODE是 Oracle 特有的简化版CASE，但选项出现语法错误。正确应为 DECODE(SIGN(years_of_service-5), 1, 15, annual_leave)），且其他数据库不支持。",
            "knowledge_comment": "使用 CASE 表达式的逻辑是：若years_of_service > 5，则将annual_leave设为 15 天；否则保持原值（ELSE annual_leave）。",
            "correct_answer": "CASE WHEN years_of_service > 5 THEN 15 ELSE annual_leave END",
            "applicable_databases": ["SQL Server"]
        },
        {
            "question_id": 6,
            "question_text_before_options": "若工龄超过5年，重置年假为15天，否则保持原值：UPDATE employees SET annual_leave = ",
            "options": ["15", "CASE WHEN years_of_service > 5 THEN 15 ELSE annual_leave END", "NVL(annual_leave, 15)", "DECODE(years_of_service, >5, 15)"],
            "question_text_after_options": " WHERE years_of_service > 5;",
            "question_comment": "直接写15会将所有员工的年假强制设为 15 天，而忽略工龄条件，导致错误。NVL(annual_leave, 15) 仅处理 annual_leave 为 NULL 的情况，无法根据工龄判断。DECODE是 Oracle 特有的简化版CASE，但选项出现语法错误。正确应为 DECODE(SIGN(years_of_service-5), 1, 15, annual_leave)）。",
            "knowledge_comment": "使用 CASE 表达式的逻辑是：若years_of_service > 5，则将annual_leave设为 15 天；否则保持原值（ELSE annual_leave）。虽然可用DECODE实现同样的需求，但不推荐（非标准）。",
            "correct_answer": "CASE WHEN years_of_service > 5 THEN 15 ELSE annual_leave END",
            "applicable_databases": ["Oracle"]
        },
        {
            "question_id": 7,
            "question_text_before_options": "将 users 表中活跃度最低的 10 个用户标记为 inactive：UPDATE users SET status = 'inactive' ORDER BY activity_score ASC ",
            "options": ["LIMIT", "TOP", "FETCH FIRST", "ROWCOUNT"],
            "question_text_after_options": " 10;",
            "question_comment": "TOP 是 SQL Server/Oracle 的语法，MySQL 不支持。MySQL 无法识别TOP关键字，会报错。FETCH FIRST是标准 SQL 语法（如 Oracle 12c+），但 MySQL 不支持。SET ROWCOUNT 是 SQL Server 的语法，用于限制后续操作的行数。MySQL 没有 ROWCOUNT 或类似机制，会报错。",
            "knowledge_comment": "MySQL 使用LIMIT关键字限制查询或更新的行数。语法：LIMIT n，其中n为行数。通过 ORDER BY activity_score ASC 排序后，使用 LIMIT 10 仅更新前 10 条记录，符合题意。",
            "correct_answer": "LIMIT",
            "applicable_databases": ["MySQL"]
        },
        {
            "question_id": 7,
            "question_text_before_options": "将 users 表中活跃度最低的 10 个用户标记为 inactive：UPDATE TOP",
            "options": ["LIMIT", "TOP", "FETCH FIRST", "ROWCOUNT"],
            "question_text_after_options": "(10) users SET status = 'inactive' ORDER BY activity_score ASC;",
            "question_comment": "LIMIT 是 MySQL 语法，SQL Server 不支持。FETCH FIRST 是标准 SQL 语法（如 Oracle），UPDATE 语句中不支持。SET ROWCOUNT 是 SQL Server 旧语法（已弃用），需单独声明，不能直接用于 UPDATE 语句。使用时应这样写：SET ROWCOUNT 10; UPDATE users SET status = 'inactive' ORDER BY activity_score ASC; SET ROWCOUNT 0; -- 恢复默认",
            "knowledge_comment": "SQL Server 使用 TOP(n) 限制更新行数，需用括号包裹数字。",
            "correct_answer": "TOP",
            "applicable_databases": ["SQL Server"]
        },
        {
            "question_id": 7,
            "question_text_before_options": "将 users 表中活跃度最低的 10 个用户标记为 inactive：UPDATE users SET status = 'inactive' WHERE user_id IN ( SELECT user_id FROM users ORDER BY activity_score ASC ",
            "options": ["LIMIT", "TOP", "FETCH FIRST", "ROWCOUNT"],
            "question_text_after_options": " 10 ROWS ONLY);",
            "question_comment": "LIMIT 是 MySQL 语法，Oracle 不支持。TOP 是 SQL Server 语法，Oracle 不支持。ROWCOUNT 是 SQL Server 用于设置影响后续行数的变量，SET ROWCOUNT 是 SQL Server 旧语法（已弃用），Oracle 无此功能。",
            "knowledge_comment": "Oracle 12c+ 支持标准 SQL 的 FETCH FIRST 语法，用于限制查询结果行数。Oracle 12c 之前需使用 ROWNUM 或窗口函数（如 ROW_NUMBER()）实现类似功能：WHERE ROWNUM <= 10  -- 无排序保证。",
            "correct_answer": "FETCH FIRST",
            "applicable_databases": ["Oracle"]
        }
    ],
    "8" : [
        {
            "question_id": 1,
            "question_text_before_options": "",
            "options": ["SELECT", "UPDATE", "DELETE", "INSERT"],
            "question_text_after_options": " FROM employees WHERE department = 'HR';",
            "question_comment": "SELECT 用于查询数据，语法为 SELECT column1, column2 FROM table_name;，此处缺少列名，或代表全部列的符号 *。UPDATE 用于修改数据，语法为 UPDATE table_name SET column = value WHERE condition;，此处缺少 SET 子句且逻辑不符。INSERT 用于插入新数据，语法为 INSERT INTO table_name (columns) VALUES (values);",
            "knowledge_comment": "DELETE FROM 是标准的删除语句语法，用于删除表中符合条件的记录。DELETE 是选项中唯一一个填入不会报错的关键字。",
            "correct_answer": "DELETE",
            "applicable_databases": ["MySQL", "SQL Server", "Oracle"]
        },
        {
            "question_id": 2,
            "question_text_before_options": "DELETE ",
            "options": ["IN", "FROM", "* FROM", "TABLE"],
            "question_text_after_options": " employees WHERE age > 60;",
            "question_comment": "IN 是用于条件筛选的操作符（如 WHERE age IN (60, 65, 70)），不能替代 FROM 关键字。* 在 SELECT 语句中表示选择所有列（如 SELECT * FROM employees），但 DELETE 语句不需要指定列，因为满足的条件的行里所有列的数据都会被删除，所以直接使用 FROM 即可。TABLE 是用于操作表结构的关键字（如 CREATE TABLE、ALTER TABLE），不能用于 DELETE 语句。",
            "knowledge_comment": "删除数据的基本语法是：DELETE FROM table_name WHERE conditionl; FROM 是 DELETE 语句中必需的关键字，用于指定要删除数据的表。",
            "correct_answer": "FROM",
            "applicable_databases": ["MySQL", "SQL Server", "Oracle"]
        },
        {
            "question_id": 3,
            "question_text_before_options": "删除没有订单的客户：DELETE customers FROM customers LEFT JOIN orders ON customers.id = orders.customer_id WHERE ",
            "options": ["orders.id","customers.id","orders.customer_id","orders"],
            "question_text_after_options": " IS NULL;",
            "question_comment": "customers.id是主键，不可能为NULL，此条件永远不成立，导致无法删除任何数据。LEFT JOIN 的条件是 customers.id = orders.customer_id，若右表无匹配记录，orders.customer_id 确实为 NULL，逻辑等价于检查 orders.id。然而，在实际业务中，orders.customer_id 可能允许为 NULL（表示无关联客户），此时会误删有订单但该字段为 NULL 的客户，因此不推荐使用，orders.id 是唯一标识，更可靠，建议选择唯一标识字段（如 orders.id）进行判断。orders 是表名，不能直接用于 IS NULL 判断，语法错误。",
            "knowledge_comment": "题目要求删除没有订单的客户，即customers表中在orders表中无匹配记录的客户。通过LEFT JOIN连接两表后，无订单的客户在右表（orders）的所有字段均为NULL，因此 orders.id 为 NULL 表示无订单。",
            "correct_answer": "orders.id",
            "applicable_databases": ["MySQL"]
        },
        {
            "question_id": 3,
            "question_text_before_options": "删除没有订单的客户：DELETE c FROM customers c LEFT JOIN orders o ON c.id = o.customer_id WHERE ",
            "options": ["o.id","c.id","o.customer_id","o"],
            "question_text_after_options": " IS NULL;",
            "question_comment": "c.id是主键，不可能为NULL，此条件永远不成立，导致无法删除任何数据。LEFT JOIN 的条件是 c.id = o.customer_id，若右表无匹配记录，o.customer_id 确实为 NULL，逻辑等价于检查 o.id。然而，在实际业务中，o.customer_id 可能允许为 NULL（表示无关联客户），此时会误删有订单但该字段为 NULL 的客户，因此不推荐使用，o.id 是唯一标识，更可靠，建议选择唯一标识字段（如 o.id）进行判断。o 是表名，不能直接用于 IS NULL 判断，语法错误。",
            "knowledge_comment": "题目要求删除没有订单的客户，即customers表中在orders表中无匹配记录的客户。通过LEFT JOIN连接两表后，无订单的客户在右表（orders）的所有字段均为NULL，因此 o.id 为 NULL 表示无订单。",
            "correct_answer": "o.id",
            "applicable_databases": ["SQL Server"]
        },
        {
            "question_id": 3,
            "question_text_before_options": "删除没有订单的客户：DELETE FROM customers WHERE id IN (SELECT c.id FROM customers c LEFT JOIN orders o ON c.id = o.customer_id WHERE ",
            "options": ["o.id","c.id","o.customer_id","o"],
            "question_text_after_options": " IS NULL);",
            "question_comment": "c.id是主键，不可能为NULL，此条件永远不成立，导致无法删除任何数据。LEFT JOIN 的条件是 c.id = o.customer_id，若右表无匹配记录，o.customer_id 确实为 NULL，逻辑等价于检查 o.id。然而，在实际业务中，o.customer_id 可能允许为 NULL（表示无关联客户），此时会误删有订单但该字段为 NULL 的客户，因此不推荐使用，o.id 是唯一标识，更可靠，建议选择唯一标识字段（如 o.id）进行判断。o 是表名，不能直接用于 IS NULL 判断，语法错误。",
            "knowledge_comment": "题目要求删除没有订单的客户，即customers表中在orders表中无匹配记录的客户。Oracle 不允许直接在 DELETE 中使用 JOIN，因此通过子查询间接实现。子查询中通过LEFT JOIN连接两表后，无订单的客户在右表（orders）的所有字段均为NULL，因此 o.id 为 NULL 表示无订单。",
            "correct_answer": "o.id",
            "applicable_databases": ["Oracle"]
        },
        {
            "question_id": 4,
            "question_text_before_options": "清空表数据：",
            "options": ["DROP", "CLEAR", "DELETE", "TRUNCATE"],
            "question_text_after_options": " TABLE orders;",
            "question_comment": "DROP TABLE orders; 会删除整张表（包括表结构），而非仅清空数据。SQL 无 CLEAR 关键字，可能混淆为编程语言（如 Python 列表的 clear() 方法）。此处不可填入 DELETE，可以清空表数据的是：DELETE FROM orders; DELETE FROM 会逐行删除数据，可回滚，且不释放表空间（仅标记为可重用）。大数据量时 TRUNCATE 远快于 DELETE。",
            "knowledge_comment": "TRUNCATE TABLE 用于快速清空表数据，释放存储空间，且操作不可回滚（直接删除数据页，不记录详细日志）。",
            "correct_answer": "TRUNCATE",
            "applicable_databases": ["MySQL", "SQL Server", "Oracle"]
        }
    ],
    "9" : [
        {
            "question_id": 1,
            "question_text_before_options": "CREATE ",
            "options": ["DB", "TABLE", "SPACE", "DATABASE"],
            "question_text_after_options": " shop_db;",
            "question_comment": "MySQL 不支持 CREATE DB，DB 不是关键字。CREATE TABLE 用于创建表，与创建数据库无关。MySQL 无 CREATE SPACE 语法，纯属干扰项。",
            "knowledge_comment": "在 MySQL 中，CREATE DATABASE 是创建数据库的标准语法，明确且唯一。MySQL 早期版本为了兼容其他数据库（如 PostgreSQL、Oracle）对 SCHEMA 的支持，引入了 SCHEMA 这一别名。在 MySQL 中，SCHEMA 等于 DATABASE，两者可互换使用。但在其他数据库中，SCHEMA 是数据库内部的逻辑分组，隶属于某个数据库。",
            "correct_answer": "DATABASE",
            "applicable_databases": ["MySQL"]
        },
        {
            "question_id": 1,
            "question_text_before_options": "CREATE ",
            "options": ["SCHEMA", "DATABASE", "DB", "NEW DATABASE"],
            "question_text_after_options": " shop_db;",
            "question_comment": "在 MySQL 中，SCHEMA 是 DATABASE 的同义词，CREATE SCHEMA 与 CREATE DATABASE 等价。但在 SQL Server 中，SCHEMA 代表数据库中的命名空间，与数据库是不同概念。DB 是 \"database\" 的缩写，但 SQL 中无 CREATE DB 语法。SQL 中无 NEW DATABASE 语法，属于干扰项。",
            "knowledge_comment": "CREATE DATABASE 是创建数据库的标准语句，直接指定数据库名称。",
            "correct_answer": "DATABASE",
            "applicable_databases": ["SQL Server"]
        },
        {
            "question_id": 1,
            "question_text_before_options": "创建数据库（SQL 语句已简化）：CREATE ",
            "options": ["SCHEMA", "DATABASE", "DB", "NEW DATABASE"],
            "question_text_after_options": " shop_db;",
            "question_comment": "在 MySQL 中，SCHEMA 是 DATABASE 的同义词，CREATE SCHEMA 与 CREATE DATABASE 等价。但在 Oracle 中，SCHEMA 代表数据库中的命名空间，与数据库是不同概念。DB 是 \"database\" 的缩写，但 SQL 中无 CREATE DB 语法。SQL 中无 NEW DATABASE 语法，属于干扰项。",
            "knowledge_comment": "CREATE DATABASE 是创建数据库的标准语句，直接指定数据库名称。Oracle 的数据库创建需要同时配置实例和物理文件，包括：指定数据文件路径、大小、自动扩展规则；配置日志组和日志文件；设置字符集、国家字符集等全局参数。推荐用 DBCA (Database Configuration Assistant) 创建数据库，因为 Oracle 数据库创建需数十个参数，手动编写 SQL 易遗漏关键配置。而 DBCA 会生成完整的 CREATE DATABASE 脚本（包含所有参数），并执行。所以为了专注于关键词练习，这里的 SQL 语句是简化后的语句，实际不止于此。Oracle 的架构设计虽然初期学习曲线陡峭，但在大型企业级应用中更具优势。",
            "correct_answer": "DATABASE",
            "applicable_databases": ["Oracle"]
        },
        {
            "question_id": 2,
            "question_text_before_options": "创建 shop_db 数据库，指定排序规则为 Latin1_General_CI_AS（不区分大小写，区分重音）：CREATE DATABASE shop_db ",
            "options": ["COLLATE", "WITH COLLATION", "ORDER BY", "ORDER COLLATION"],
            "question_text_after_options": " Latin1_General_CI_AS;",
            "question_comment": "WITH COLLATION 不是标准语法，应使用 COLLATE。ORDER BY 用于查询结果排序，非建库语法。ORDER COLLATION 则是纯粹的干扰项，无此类语法。",
            "knowledge_comment": "SQL Server 中字符集是隐式确定的，不可直接设置。SQL Server 的字符集机制：默认使用 Unicode（UTF-16），字符集不可通过 COLLATE 或建库语句显式修改。使用 COLLATE 指定排序规则，控制字符比较的规则，决定如何对字符串进行排序和比较，它定义字符的排序顺序、大小写敏感性、重音敏感性等规则。它能够决定 ORDER BY 的结果顺序。",
            "correct_answer": "COLLATE",
            "applicable_databases": ["SQL Server"]
        },
        {
            "question_id": 2,
            "question_text_before_options": "创建 shop_db 数据库，指定字符集为 utf8mb4：CREATE DATABASE shop_db ",
            "options": ["CHARSET = ", "CHARACTER SET", "SET CHARSET", "USING CHARACTER"],
            "question_text_after_options": " utf8mb4;",
            "question_comment": "CHARSET = 是 ALTER DATABASE 语句的语法（如 ALTER DATABASE db_name CHARACTER SET = utf8mb4），非建库语法。SET CHARSET & USING CHARACTER 错误，无此类语法。",
            "knowledge_comment": "标准 SQL 中指定字符集的完整语法是 CHARACTER SET。需要注意的是：MySQL 支持 CHARSET 作为 CHARACTER SET 的简写。字符集是编码规则，决定如何将字符（如 A、中）存储为二进制数据。不同字符集支持的字符范围和编码方式不同。字符集能够决定数据库能存储哪些字符（如中文、 emoji）。不同字符集占用空间不同（如 utf8 vs utf8mb4）。常见字符集有：latin，适合存储纯英文数据。utf8，适合中英文混合场景，但要求无特殊符合，比如 emoji。utf8mb4，覆盖所有 Unicode，包含emoji，擅长处理现代社交应用数据。",
            "correct_answer": "CHARACTER SET",
            "applicable_databases": ["MySQL"]
        },
        {
            "question_id": 3,
            "question_text_before_options": "创建 shop_db 数据库，指定字符集为 utf8mb4、排序规则为 utf8mb4_unicode_ci：CREATE DATABASE shop_db CHARSET utf8mb4 ",
            "options": ["COLLATE", "WITH COLLATION", "ORDER BY", "ORDER COLLATION"],
            "question_text_after_options": " utf8mb4_unicode_ci;",
            "question_comment": "WITH COLLATION 不是标准语法，应使用 COLLATE。ORDER BY 用于查询结果排序，非建库语法。ORDER COLLATION 则是纯粹的干扰项，无此类语法。",
            "knowledge_comment": "标准 SQL 和 MySQL 统一使用 COLLATE 指定排序规则。排序规则 (Collation) 是比较字符的规则，决定如何对字符串进行排序和比较（如 A 和 a 是否相等）。它能够决定 ORDER BY 的结果顺序（如中文按拼音还是笔画排序）；控制比较时是否区分大小写（如 A vs a）；控制比较时是否区分重音（如 é vs e）。常见的排序规则有：utf8_general_ci，适合对 utf8 字符集进行排序，大小写不敏感、重音不敏感。utf8_bin，适合对 utf8 字符集进行排序，大小写敏感、重音敏感。utf8mb4_unicode_ci，适合对 utf8mb4 字符集进行排序，大小写不敏感、重音部分敏感，按 Unicode标准排序。每个字符集有多个对应的排序规则（如 utf8mb4 对应 utf8mb4_unicode_ci、utf8mb4_bin 等）。",
            "correct_answer": "COLLATE",
            "applicable_databases": ["MySQL"]
        },
        {
            "question_id": 2,
            "question_text_before_options": "创建 shop_db 数据库，指定字符集为 AL32UTF8（SQL 语句已简化）：CREATE DATABASE shop_db ",
            "options": ["CHARSET", "CHARACTER SET", "ENCODING", "WITH CHARACTER"],
            "question_text_after_options": " AL32UTF8;",
            "question_comment": "CHARSET 是 MySQL 简写语法，Oracle 不支持。ENCODING & WITH CHARACTER 错误，无此类语法。",
            "knowledge_comment": "标准 SQL 中指定字符集的完整语法是 CHARACTER SET。字符集是编码规则，决定如何将字符（如 A、中）存储为二进制数据。不同字符集支持的字符范围和编码方式不同。字符集能够决定数据库能存储哪些字符（如中文、 emoji）。不同字符集占用空间不同。Oracle 的数据库创建需要同时配置实例和物理文件，包括：指定数据文件路径、大小、自动扩展规则；配置日志组和日志文件；设置字符集、国家字符集等全局参数。推荐用 DBCA (Database Configuration Assistant) 创建数据库，因为 Oracle 数据库创建需数十个参数，手动编写 SQL 易遗漏关键配置。而 DBCA 会生成完整的 CREATE DATABASE 脚本（包含所有参数），并执行。所以为了专注于关键词练习，这里的 SQL 语句是简化后的语句，实际不止于此。",
            "correct_answer": "CHARACTER SET",
            "applicable_databases": ["Oracle"]
        },
        {
            "question_id": 3,
            "question_text_before_options": "创建 shop_db 数据库，指定字符集为 AL32UTF8、排序规则为 AL32UTF8_GENERAL_CI（SQL 语句已简化）：CREATE DATABASE shop_db CHARACTER SET AL32UTF8 ",
            "options": ["NLS_COLLATE", "NLS_SORT", "COLLATE", "SORT_RULE"],
            "question_text_after_options": " = 'AL32UTF8_GENERAL_CI';",
            "question_comment": "NLS_COLLATE 用于国家字符集排序。COLLATE 是 MySQL/SQL Server 中指定排序规则的关键字，后不可跟 = ，且 Oracle 不支持 COLLATE 关键字。SORT_RULE 是纯粹的干扰项，不存在此语法。",
            "knowledge_comment": "Oracle 中通过 NLS_SORT 参数指定排序规则。排序规则 (Collation) 是比较字符的规则，决定如何对字符串进行排序和比较（如 A 和 a 是否相等）。它能够决定 ORDER BY 的结果顺序（如中文按拼音还是笔画排序）；控制比较时是否区分大小写（如 A vs a）；控制比较时是否区分重音（如 é vs e）。Oracle 的数据库创建需要同时配置实例和物理文件，包括：指定数据文件路径、大小、自动扩展规则；配置日志组和日志文件；设置字符集、国家字符集等全局参数。推荐用 DBCA (Database Configuration Assistant) 创建数据库，因为 Oracle 数据库创建需数十个参数，手动编写 SQL 易遗漏关键配置。而 DBCA 会生成完整的 CREATE DATABASE 脚本（包含所有参数），并执行。所以为了专注于关键词练习，这里的 SQL 语句是简化后的语句，实际不止于此。",
            "correct_answer": "NLS_SORT",
            "applicable_databases": ["Oracle"]
        },
        {
            "question_id": 4,
            "question_text_before_options": "创建一个用于数据库 order_db，并在其中创建 orders 表：",
            "options": ["CREATE TABLE order_db.orders (...); CREATE DATABASE order_db;", "CREATE DATABASE order_db; USE order_db; CREATE TABLE orders (...);" ,"CREATE DATABASE order_db; CREATE TABLE orders (...);","USE order_db; CREATE DATABASE order_db; CREATE TABLE orders (...);"],
            "question_text_after_options": "",
            "question_comment": "必须先创建数据库（CREATE DATABASE），再使用 USE 切换到该数据库，最后创建表。按照此流程的写法才是正解。",
            "knowledge_comment": "必须先创建数据库（CREATE DATABASE），再使用 USE 切换到该数据库，最后创建表。USE 关键词切用于换上下文，保证在正确的数据库中创建表。",
            "correct_answer": "CREATE DATABASE order_db; USE order_db; CREATE TABLE orders (...);",
            "applicable_databases": ["MySQL", "SQL Server"]
        },
        {
            "question_id": 4,
            "question_text_before_options": "创建一个用于数据库 order_db，并在其中创建 orders 表（SQL 语句已简化）：",
            "options": ["CREATE TABLE order_db.orders (...); CREATE DATABASE order_db;", "CREATE DATABASE order_db; USE order_db; CREATE TABLE orders (...);" ,"CREATE DATABASE order_db; CREATE TABLE orders (...);","USE order_db; CREATE DATABASE order_db; CREATE TABLE orders (...);"],
            "question_text_after_options": "",
            "question_comment": "在 Oracle 中使用 USE 语句会直接报错，因为 Oracle 不支持 USE 语法。数据库一旦创建，所有表直接隶属于该实例，所以无需 USE 语句切换。表的创建需直接指定表空间（默认使用 USERS 表空间）。",
            "knowledge_comment": "Oracle 的流程为：CREATE DATABASE（系统级）→ 直接 CREATE TABLE（无需切换，表隶属于当前实例）。Oracle 的数据库创建需要同时配置实例和物理文件，包括：指定数据文件路径、大小、自动扩展规则；配置日志组和日志文件；设置字符集、国家字符集等全局参数。推荐用 DBCA (Database Configuration Assistant) 创建数据库，因为 Oracle 数据库创建需数十个参数，手动编写 SQL 易遗漏关键配置。而 DBCA 会生成完整的 CREATE DATABASE 脚本（包含所有参数），并执行。所以为了专注于关键词练习，这里的 SQL 语句是简化后的语句，实际不止于此。",
            "correct_answer": "CREATE DATABASE order_db; CREATE TABLE orders (...);",
            "applicable_databases": ["Oracle"]
        }
    ],
    "10": [
        {
            "question_id": 1,
            "question_text_before_options": "",
            "options": ["DROP", "DELETE", "REMOVE", "DESTROY"],
            "question_text_after_options": " DATABASE testDB;",
            "question_comment": "DELETE FROM 用于删除表中的数据行，而非整个数据库或表结构。REMOVE 在标准 SQL 中完全不存在，既不用于删除数据库，也不用于其他操作。在 MySQL 中，REMOVE 唯一可能出现的场景是作为 DROP 的别名出现在 ALTER TABLE 语句的非标准语法中（极少数情况），例如：ALTER TABLE table_name DROP|REMOVE COLUMN column_name; 用于移除列。此处 REMOVE 是 DROP 的非标准别名（仅用于列的删除），但绝不能用于删除数据库。注意：这种用法并非 MySQL 官方推荐，且仅限 ALTER TABLE 场景，与数据库删除无关。标准 SQL 中不存在 DESTROY 关键字，此为非 SQL 术语，可能与操作系统层面的文件删除混淆（如删除数据库文件），但不属于 SQL 语法范畴。",
            "knowledge_comment": "DROP DATABASE 是删除数据库的标准语法，用于永久删除整个数据库，包括数据库中的所有表、数据、索引、视图等对象。语法：DROP DATABASE [IF EXISTS] database_name; IF EXISTS 可选，用于避免删除不存在的数据库时抛出错误。当需要彻底移除不再使用的数据库时使用，操作不可逆，需谨慎执行。",
            "correct_answer": "DROP",
            "applicable_databases": ["MySQL", "SQL Server", "Oracle"]
        }
    ],
    "11" : [
        {
            "question_id": 1,
            "question_text_before_options": "",
            "options": ["ALTER", "UPDATE", "SET", "MODIFY"],
            "question_text_after_options": " DATABASE mydb CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;",
            "question_comment": "UPDATE 和 SET 是修改表中数据时的关键词，MODIFY 用于表结构修改，它们都不能用于修改数据库。",
            "knowledge_comment": "ALTER DATABASE mydb CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci; 这个命令会将整个数据库的字符集修改为utf8mb4，并且使用utf8mb4_unicode_ci排序规则。你会发现这句话除了 ALTER 关键词外，其他部分都和创建数据库时指定字符集和排序规则的部分一样。一样的语句降低了掌握的成本。",
            "correct_answer": "ALTER",
            "applicable_databases": ["MySQL"]
        },
        {
            "question_id": 1,
            "question_text_before_options": "",
            "options": ["ALTER", "UPDATE", "SET", "MODIFY"],
            "question_text_after_options": " DATABASE mydb COLLATE Latin1_General_CI_AS;",
            "question_comment": "UPDATE 和 SET 是修改表中数据时的关键词，MODIFY 在 MySQL 和 Oracle 中可用于表结构修改，但在 SQL Server 2016+ 之后则可用于数据库的重命名，因此此处只可填入 ALTER。",
            "knowledge_comment": "ALTER DATABASE mydb COLLATE Latin1_General_CI_AS; 这个命令会将整个数据库的字符集和排序规则修改为 Latin1_General_CI_AS。你会发现这句话除了 ALTER 关键词外，其他部分都和创建数据库时指定字符集和排序规则的部分一样。一样的语句降低了掌握的成本。",
            "correct_answer": "ALTER",
            "applicable_databases": ["SQL Server"]
        },
        {
            "question_id": 1,
            "question_text_before_options": "简化版：",
            "options": ["ALTER", "UPDATE", "SET", "MODIFY"],
            "question_text_after_options": " DATABASE CHARACTER SET AL32UTF8;",
            "question_comment": "UPDATE 和 SET 是修改表中数据时的关键词，MODIFY 用于表结构修改，因此它们都不能用于修改数据库。",
            "knowledge_comment": "ALTER DATABASE CHARACTER SET AL32UTF8; 这个命令会将整个数据库的字符集修改为 AL32UTF8。你可能发现这句话中并未指明 database_name，没错，在 Oracle 数据库中，ALTER DATABASE 命令确实不需要显式指定数据库名称。这是因为 Oracle 的架构设计与 MySQL、SQL Server 等数据库不同。Oracle 是单实例单数据库的架构，一个 Oracle 实例（由内存结构和后台进程组成）通常只关联一个数据库（由数据文件、控制文件、日志文件组成）。因此，当您通过 SQL*Plus 或其他工具连接到某个 Oracle 实例时，所有 ALTER DATABASE 操作默认针对该实例关联的唯一数据库。",
            "correct_answer": "ALTER",
            "applicable_databases": ["Oracle"]
        },
        {
            "question_id": 2,
            "question_text_before_options": "修改会话级排序规则：ALTER SESSION SET ",
            "options": ["NLS_SORT", "NLS_COMP" , "COLLATION", "NLS_COLLATE"],
            "question_text_after_options": " = 'BINARY_CI'; ALTER SESSION SET NLS_COMP = 'LINGUISTIC';",
            "question_comment": "NLS_COMP 定义字符数据的比较规则，此处的 COMP 是 Comparison的简写，它控制 WHERE 条件、JOIN 等场景的行为。鉴于后跟参数为 BINARY_CI，而 NLS_COMP 的可选值只有 BINARY 和 LINGUISTIC，没有 BINARY_CI 或其他类似值，因此本处不可填入 NLS_COMP。此外本句后还有一句设置 NLS_COMP，同时设置 NLS_SORT 和 NLS_COMP 才能确保排序和比较行为一致。COLLATION 不是 SQL 关键词，干扰项。NLS_COLLATE 用于国家字符集排序。",
            "knowledge_comment": "NLS_SORT 参数（如 BINARY、LINGUISTIC 等）定义字符数据的排序规则，即 ORDER BY、索引排序等场景的行为。但严格来说，Oracle 的排序规则更多依赖字符集和会话参数，无法直接修改数据库级别的排序规则。",
            "correct_answer": "NLS_SORT",
            "applicable_databases": ["Oracle"]
        },
        {
            "question_id": 3,
            "question_text_before_options": "重命名 SQL Server 数据库（2016+）：ALTER DATABASE mydb SET SINGLE_USER WITH ROLLBACK IMMEDIATE; ALTER DATABASE mydb ",
            "options": ["SET", "MODIFY" , "RENAME", "ALTER"],
            "question_text_after_options": " NAME = newdb; ALTER DATABASE newdb SET MULTI_USER;",
            "question_comment": "SET 可用于修改数据库选项（如 SET READ_ONLY）。原生 SQL 中无 RENAME DATABASE 语法。重命名表或列需用 sp_rename 存储过程（如 EXEC sp_rename 'old_table', 'new_table'），但该存储过程不能用于重命名数据库。ALTER 已在语句开头，不能重复使用。",
            "knowledge_comment": "SQL Server 2016+ 支持 ALTER DATABASE ... MODIFY NAME = new_name;",
            "correct_answer": "MODIFY",
            "applicable_databases": ["SQL Server"]
        },
        {
            "question_id": 4,
            "question_text_before_options": "修改主数据文件自动增长为 100MB，最大 1GB：ALTER DATABASE mydb ",
            "options": ["MODIFY", "MODIFY FILE" ,"ALTER","ALTER FILE"],
            "question_text_after_options": " (NAME = mydb_data, FILEGROWTH = 100MB, MAXSIZE = 1GB);",
            "question_comment": "单独使用 MODIFY 无法指定操作对象为文件，必须搭配 FILE 关键字（即 MODIFY FILE）。ALTER 仅用于开启语句，无法直接修饰文件操作，需随后搭配 MODIFY FILE 使用。修改文件属性需用 MODIFY 而非 ALTER，正确组合为 MODIFY FILE，而非 ALTER FILE。",
            "knowledge_comment": "SQL Server 中修改数据库文件属性的完整语法为 ALTER DATABASE ... MODIFY FILE (...)，MODIFY FILE 是固定关键字组合，不可拆分。FILEGROWTH 需显式指定单位（MB/GB/%等），如果不指定单位，则默认使用 MB。使用百分比（如 10%）时，增长量会随文件变大而逐渐增加，可能导致后期文件膨胀过快。因此建议对稳定增长的数据库使用固定值（如 100MB）。频繁的小幅度增长（如 1 MB）可能影响性能，建议根据业务负载设置合理的增长量。",
            "correct_answer": "MODIFY FILE",
            "applicable_databases": ["SQL Server"]
        },
        {
            "question_id": 4,
            "question_text_before_options": "修改主数据文件自动增长为 100MB，最大 1GB：ALTER DATABASE DATAFILE '/path/to/file.dbf' AUTOEXTEND ON ",
            "options": ["SIZE" ,"STEP", "NEXT", "INCREMENT"],
            "question_text_after_options": " 100M MAXSIZE 1G;",
            "question_comment": "SIZE 用于创建文件时指定初始大小（如 SIZE 1G）。STEP 非 Oracle 关键字。INCREMENT 用于表空间默认扩展（如 CREATE TABLESPACE ... INCREMENT BY）。",
            "knowledge_comment": "Oracle 中指定自动增长步长的关键字为 NEXT。Oracle 中自动增长单位用 M 表示 MB，NEXT 100M 即每次扩展 100MB。如果不指定单位，默认单位是数据库块大小（DB_BLOCK_SIZE），通常默认为 8 KB。频繁的小幅度扩展（如 100 KB）会导致性能开销，建议合理设置扩展量（例如每次扩展 100 MB）。",
            "correct_answer": "NEXT",
            "applicable_databases": ["Oracle"]
        }
    ]
}